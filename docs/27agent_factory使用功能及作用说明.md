# Agent Factory æ™ºèƒ½ä½“å·¥å‚è¯¦ç»†åˆ†æè¯´æ˜

## ğŸ“‹ æ¦‚è¿°

`Agent Factory`æ˜¯Cooragentç³»ç»Ÿä¸­çš„**æ™ºèƒ½ä½“åŠ¨æ€åˆ›å»ºå¼•æ“**ï¼Œè´Ÿè´£æ ¹æ®ç”¨æˆ·éœ€æ±‚åˆ†æå’Œç”Ÿæˆä¸“ä¸šåŒ–æ™ºèƒ½ä½“ã€‚å®ƒæ˜¯ç³»ç»Ÿ**è‡ªé€‚åº”æ‰©å±•èƒ½åŠ›**çš„æ ¸å¿ƒç»„ä»¶ï¼Œèƒ½å¤Ÿåœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ›å»ºæ–°çš„æ™ºèƒ½ä½“æ¥æ»¡è¶³ç‰¹å®šé¢†åŸŸæˆ–å¤æ‚ä»»åŠ¡çš„éœ€æ±‚ã€‚

---

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½ä¸èŒè´£

### 1. **éœ€æ±‚åˆ†æä¸æ™ºèƒ½ä½“è®¾è®¡ (Requirement Analysis & Agent Design)**
- **é¢†åŸŸè¯†åˆ«**: åˆ†æç”¨æˆ·éœ€æ±‚ï¼Œè¯†åˆ«æ‰€éœ€çš„ä¸“ä¸šé¢†åŸŸå’Œèƒ½åŠ›
- **æ¶æ„è®¾è®¡**: åŸºäºéœ€æ±‚è®¾è®¡æ™ºèƒ½ä½“çš„è§’è‰²ã€èƒ½åŠ›å’Œå·¥å…·é…ç½®
- **é€šç”¨æ€§ä¿è¯**: ç¡®ä¿åˆ›å»ºçš„æ™ºèƒ½ä½“å…·æœ‰å¯é‡ç”¨æ€§å’Œé€šç”¨æ€§
- **é…ç½®ç”Ÿæˆ**: ç”Ÿæˆå®Œæ•´çš„æ™ºèƒ½ä½“JSONé…ç½®

### 2. **å·¥å…·é“¾æ™ºèƒ½é€‰æ‹© (Intelligent Tool Selection)**
- **éœ€æ±‚åŒ¹é…**: æ ¹æ®æ™ºèƒ½ä½“èƒ½åŠ›éœ€æ±‚é€‰æ‹©åˆé€‚çš„å·¥å…·
- **æƒé™æ§åˆ¶**: ç¡®ä¿åªé€‰æ‹©å¿…è¦ä¸”å¯ç”¨çš„å·¥å…·
- **MCPé›†æˆ**: æ”¯æŒé€‰æ‹©å’Œé›†æˆMCPåè®®å·¥å…·
- **å·¥å…·éªŒè¯**: éªŒè¯é€‰å®šå·¥å…·çš„å¯ç”¨æ€§å’Œå…¼å®¹æ€§

### 3. **æç¤ºè¯å·¥ç¨‹ (Prompt Engineering)**
- **ä¸“ä¸šåŒ–è®¾è®¡**: ä¸ºæ¯ä¸ªæ™ºèƒ½ä½“åˆ›å»ºä¸“ä¸šåŒ–çš„æç¤ºè¯æ¨¡æ¿
- **è¡Œä¸ºè§„èŒƒ**: å®šä¹‰æ™ºèƒ½ä½“çš„å·¥ä½œæµç¨‹å’Œè¡Œä¸ºå‡†åˆ™
- **è¯­è¨€ä¸€è‡´æ€§**: ç¡®ä¿æç¤ºè¯è¯­è¨€ä¸ç”¨æˆ·è¾“å…¥è¯­è¨€ä¸€è‡´
- **æœ€ä½³å®è·µ**: æ•´åˆé¢†åŸŸæœ€ä½³å®è·µåˆ°æç¤ºè¯ä¸­

### 4. **LLMç±»å‹é€‚é… (LLM Type Adaptation)**
- **ä»»åŠ¡å¤æ‚åº¦è¯„ä¼°**: æ ¹æ®ä»»åŠ¡å¤æ‚åº¦é€‰æ‹©åˆé€‚çš„LLMç±»å‹
- **æ€§èƒ½ä¼˜åŒ–**: ä¸ºä¸åŒç±»å‹ä»»åŠ¡é€‰æ‹©æœ€ä¼˜çš„æ¨¡å‹é…ç½®
- **å¤šæ¨¡æ€æ”¯æŒ**: æ”¯æŒæ–‡æœ¬ã€ä»£ç ã€æ¨ç†ã€è§†è§‰ç­‰ä¸åŒæ¨¡æ€çš„LLM
- **æˆæœ¬æ•ˆç›Š**: åœ¨æ€§èƒ½å’Œæˆæœ¬ä¹‹é—´æ‰¾åˆ°æœ€ä½³å¹³è¡¡

### 5. **æ™ºèƒ½ä½“æ³¨å†Œä¸é›†æˆ (Agent Registration & Integration)**
- **åŠ¨æ€æ³¨å†Œ**: å°†æ–°åˆ›å»ºçš„æ™ºèƒ½ä½“æ³¨å†Œåˆ°ç³»ç»Ÿä¸­
- **é…ç½®æŒä¹…åŒ–**: å°†æ™ºèƒ½ä½“é…ç½®ä¿å­˜åˆ°storeç›®å½•
- **å›¢é˜Ÿé›†æˆ**: å°†æ–°æ™ºèƒ½ä½“é›†æˆåˆ°ç°æœ‰çš„å›¢é˜Ÿåä½œä½“ç³»
- **ç‰ˆæœ¬ç®¡ç†**: æ”¯æŒæ™ºèƒ½ä½“çš„ç‰ˆæœ¬æ§åˆ¶å’Œæ›´æ–°

---

## ğŸ—ï¸ ä»£ç ç»“æ„ä¸å®ç°åˆ†æ

### 1. **æ ¸å¿ƒå®ç°æ–‡ä»¶ç»“æ„**

#### **src/prompts/agent_factory.md** - æ™ºèƒ½ä½“åˆ›å»ºæŒ‡ä»¤
```markdown
# Role: Agent Builder
You are `AgentFactory`, a master AI agent builder.

# PRIMARY DIRECTIVE
Your SOLE purpose is to generate a complete JSON configuration for a NEW agent 
based on specifications found in the user's input.

# CRITICAL RULES
1. DO NOT USE YOUR OWN NAME: agent_name MUST NOT be "agent_factory"
2. SOURCE OF TRUTH: agent_name MUST match the name in [new_agents_needed:]
3. NO yfinance TOOL: Strictly forbidden from selecting yfinance tool
4. TOOL SELECTION IS CRITICAL: Only select DIRECTLY ESSENTIAL tools

# Core Workflow
1. Identify Task from User Input
2. Formulate Thought
3. Determine LLM Type
4. Select Necessary Tools
5. Construct Agent's Prompt
6. Generate Final JSON Output

# Output Format
interface AgentBuilder {
  agent_name: string;
  agent_description: string;
  thought: string;
  llm_type: string;
  selected_tools: Tool[];
  prompt: string;
}
```

#### **src/prompts/agent_factory_planner.md** - æ™ºèƒ½ä½“è§„åˆ’æŒ‡ä»¤
```markdown
# Role: AI Agent Architect
You are a top-tier AI Agent Architect, specializing in designing highly modular, 
reusable, and general-purpose agents.

# Design Philosophy
- Generality and Reusability: Every agent must be general-purpose
- Parameter-driven: Specific details are runtime parameters, not core definition
- Language Consistency: Match user's input language

# Workflow
1. Think & Analyze: Identify capability gap
2. Evaluate Existing Team: Check if existing agents suffice
3. Design New Agent: Create general-purpose agent if needed
4. Generate Execution Plan: Create agent_factory step

# Output Format
{
  "thought": "Analysis and reasoning",
  "new_agents_needed": [...],
  "steps": [{"agent_name": "agent_factory", ...}]
}
```

### 2. **ä¸»è¦å®ç°æ–‡ä»¶**

#### **src/workflow/coor_task.py: agent_factory_node()** (ä¸»å·¥ä½œæµå®ç°)
```python
async def agent_factory_node(state: State) -> Command[Literal["publisher", "__end__"]]:
    """æ™ºèƒ½ä½“å·¥å‚èŠ‚ç‚¹ - ä¸»å·¥ä½œæµç‰ˆæœ¬"""
    
    # === ç¬¬ä¸€é˜¶æ®µï¼šåˆå§‹åŒ–å’Œæ—¥å¿—è®°å½• ===
    logger.info("Agent Factory Start to work in %s workmode", state["workflow_mode"])
    
    factory_start_log = generate_chinese_log(
        "agent_factory_start",
        "ğŸ­ æ™ºèƒ½ä½“å·¥å‚å¯åŠ¨ï¼Œå¼€å§‹åˆ†ææ™ºèƒ½ä½“åˆ›å»ºéœ€æ±‚",
        workflow_mode=state["workflow_mode"],
        user_id=state.get("user_id", "unknown"),
        workflow_id=state.get("workflow_id", "unknown")
    )
    
    # === ç¬¬äºŒé˜¶æ®µï¼šçŠ¶æ€ç®¡ç†å’Œæç¤ºè¯åº”ç”¨ ===
    if state["workflow_mode"] == "launch":
        # æ¢å¤ç³»ç»ŸèŠ‚ç‚¹çŠ¶æ€
        cache.restore_system_node(state["workflow_id"], AGENT_FACTORY, state["user_id"])
        
        # åº”ç”¨æ™ºèƒ½ä½“å·¥å‚æç¤ºè¯æ¨¡æ¿
        messages = apply_prompt_template("agent_factory", state)
        
        # === ç¬¬ä¸‰é˜¶æ®µï¼šLLMè°ƒç”¨å’Œæ™ºèƒ½ä½“è§„æ ¼ç”Ÿæˆ ===
        agent_spec = await (
            get_llm_by_type(AGENT_LLM_MAP["agent_factory"])  # "basic"
            .with_structured_output(AgentBuilder)
            .ainvoke(messages)
        )
        
        # === ç¬¬å››é˜¶æ®µï¼šå·¥å…·éªŒè¯å’Œé€‰æ‹© ===
        tools = []
        validated_tools = []
        
        for tool in agent_spec["selected_tools"]:
            if agent_manager.available_tools.get(tool["name"]):
                tools.append(agent_manager.available_tools[tool["name"]])
                validated_tools.append(tool["name"])
            else:
                logger.warning("Tool (%s) is not available", tool["name"])
        
        # === ç¬¬äº”é˜¶æ®µï¼šæ™ºèƒ½ä½“åˆ›å»ºå’Œæ³¨å†Œ ===
        await agent_manager._create_agent_by_prebuilt(
            user_id=state["user_id"],
            name=agent_spec["agent_name"],
            nick_name=agent_spec["agent_name"],
            llm_type=agent_spec["llm_type"],
            tools=tools,
            prompt=agent_spec["prompt"],
            description=agent_spec["agent_description"],
        )
        
        # === ç¬¬å…­é˜¶æ®µï¼šå›¢é˜Ÿæ›´æ–°å’ŒçŠ¶æ€è¿”å› ===
        state["TEAM_MEMBERS"].append(agent_spec["agent_name"])
        
        return Command(
            update={
                "messages": [{
                    "content": f"New agent {agent_spec['agent_name']} created successfully.",
                    "tool": "agent_factory",
                    "role": "assistant",
                }],
                "new_agent_name": agent_spec["agent_name"],
                "agent_name": "agent_factory",
            },
            goto="publisher",
        )
    else:
        # élaunchæ¨¡å¼å¤„ç†é€»è¾‘
        return Command(goto="publisher", update={"agent_name": "agent_factory"})
```

#### **src/workflow/agent_factory.py: agent_factory_node()** (ç®€åŒ–å·¥ä½œæµå®ç°)
```python
async def agent_factory_node(state: State) -> Command[Literal["publisher", "__end__"]]:
    """æ™ºèƒ½ä½“å·¥å‚èŠ‚ç‚¹ - ç®€åŒ–ç‰ˆæœ¬ï¼ˆä¸“ç”¨äºagent_factoryå·¥ä½œæµï¼‰"""
    
    # 1. ç›´æ¥åº”ç”¨æç¤ºè¯æ¨¡æ¿
    messages = apply_prompt_template("agent_factory", state)
    
    # 2. è°ƒç”¨LLMç”Ÿæˆæ™ºèƒ½ä½“è§„æ ¼
    agent_spec = await (
        get_llm_by_type(AGENT_LLM_MAP["agent_factory"])
        .with_structured_output(AgentBuilder)
        .ainvoke(messages)
    )
    
    # 3. å·¥å…·éªŒè¯å’Œé€‰æ‹©
    tools = []
    for tool in agent_spec["selected_tools"]:
        if agent_manager.available_tools.get(tool["name"]):
            tools.append(agent_manager.available_tools[tool["name"]])
        else:
            logger.warning("Tool (%s) is not available", tool["name"])
    
    # 4. åˆ›å»ºæ™ºèƒ½ä½“
    await agent_manager._create_agent_by_prebuilt(
        user_id=state["user_id"],
        name=agent_spec["agent_name"],
        nick_name=agent_spec["agent_name"],
        llm_type=agent_spec["llm_type"],
        tools=tools,
        prompt=agent_spec["prompt"],
        description=agent_spec["agent_description"],
    )
    
    # 5. æ›´æ–°å›¢é˜Ÿæˆå‘˜å¹¶ç»“æŸ
    state["TEAM_MEMBERS"].append(agent_spec["agent_name"])
    
    return Command(
        update={
            "messages": [{
                "content": f"New agent {agent_spec['agent_name']} created.",
                "tool": "agent_factory",
                "role": "assistant",
            }],
            "new_agent_name": agent_spec["agent_name"],
            "agent_name": "agent_factory",
        },
        goto="__end__",  # ç®€åŒ–ç‰ˆç›´æ¥ç»“æŸ
    )
```

### 3. **æ•°æ®ç»“æ„ä¸æ¥å£å®šä¹‰**

#### **AgentBuilderæ¥å£** (src/interface/serializer.py)
```python
class AgentBuilder(TypedDict):
    """æ™ºèƒ½ä½“æ„å»ºå™¨æ•°æ®ç»“æ„"""
    
    agent_name: str              # æ™ºèƒ½ä½“å”¯ä¸€æ ‡è¯†åç§°
    agent_description: str       # æ™ºèƒ½ä½“åŠŸèƒ½æè¿° (ä¸€å¥è¯æ¦‚æ‹¬)
    thought: str                 # è®¾è®¡æ€è·¯å’Œæ¨ç†è¿‡ç¨‹
    llm_type: str               # LLMç±»å‹: "basic"|"reasoning"|"vision"|"code"
    selected_tools: list[AgentTool]  # é€‰æ‹©çš„å·¥å…·åˆ—è¡¨
    prompt: str                  # æ™ºèƒ½ä½“æ‰§è¡Œæç¤ºè¯

class AgentTool(TypedDict):
    """å·¥å…·é…ç½®æ•°æ®ç»“æ„"""
    
    name: str                    # å·¥å…·åç§° (å¿…é¡»åœ¨available_toolsä¸­å­˜åœ¨)
    description: str             # å·¥å…·åŠŸèƒ½æè¿°

class NewAgent(TypedDict):
    """æ–°æ™ºèƒ½ä½“éœ€æ±‚æè¿°"""
    
    name: str                    # æ™ºèƒ½ä½“åç§° (PascalCase)
    role: str                    # è§’è‰²å®šä¹‰ (é€šç”¨æ€§æè¿°)
    capabilities: list[str]      # èƒ½åŠ›åˆ—è¡¨ (å…·ä½“æŠ€èƒ½æè¿°)
    contribution: str            # è´¡çŒ®ä»·å€¼ (é•¿æœŸä»·å€¼è¯´æ˜)
```

### 4. **å·¥ä½œæµé›†æˆä¸è°ƒç”¨é“¾è·¯**

#### **å®Œæ•´è°ƒç”¨æµç¨‹**
```python
# 1. å·¥ä½œæµå¯åŠ¨åˆ¤æ–­
if task_type == TaskType.AGENT_FACTORY:
    graph = agent_factory_graph()    # ä½¿ç”¨ç®€åŒ–ç‰ˆå·¥ä½œæµ
else:
    graph = build_graph()           # ä½¿ç”¨å®Œæ•´ç‰ˆå·¥ä½œæµ

# 2. å·¥ä½œæµå›¾æ„å»º
def agent_factory_graph():
    workflow = AgentWorkflow()
    workflow.add_node("coordinator", coordinator_node)
    workflow.add_node("planner", planner_node)           # ä½¿ç”¨agent_factory_planner.md
    workflow.add_node("publisher", publisher_node)       # ä¸“ç”¨publisher (åªèƒ½é€‰æ‹©agent_factory)
    workflow.add_node("agent_factory", agent_factory_node)
    workflow.set_start("coordinator")
    return workflow.compile()

# 3. æ‰§è¡Œåºåˆ—
"""
ç”¨æˆ·è¾“å…¥ â†’ Coordinator(åˆ†æ) â†’ Planner(è§„åˆ’æ–°æ™ºèƒ½ä½“) â†’ Publisher(è°ƒåº¦) â†’ Agent_Factory(åˆ›å»º) â†’ ç»“æŸ
                    â†“                    â†“                     â†“               â†“
              ç®€å•å›å¤/å¤æ‚ä»»åŠ¡      ç”Ÿæˆnew_agents_needed     é€‰æ‹©agent_factory    å®é™…åˆ›å»ºæ™ºèƒ½ä½“
"""
```

---

## ğŸ”§ Agent Factoryä½¿ç”¨åŠŸèƒ½è¯¦ç»†è¯´æ˜

### 1. **è§¦å‘æ¡ä»¶ä¸ä½¿ç”¨åœºæ™¯**

#### **è‡ªåŠ¨è§¦å‘åœºæ™¯**
```python
# åœºæ™¯1: Plannerè¯†åˆ«éœ€è¦æ–°æ™ºèƒ½ä½“
planner_output = {
    "thought": "ç°æœ‰å›¢é˜Ÿç¼ºä¹ä¸“ä¸šçš„æ•°æ®åˆ†æèƒ½åŠ›",
    "new_agents_needed": [{
        "name": "DataAnalyst",
        "role": "ä¸“ä¸šæ•°æ®åˆ†æå¸ˆ",
        "capabilities": ["æ•°æ®æ¸…æ´—", "ç»Ÿè®¡åˆ†æ", "å¯è§†åŒ–"],
        "contribution": "æä¾›ä¸“ä¸šçš„æ•°æ®æ´å¯Ÿèƒ½åŠ›"
    }],
    "steps": [{
        "agent_name": "agent_factory",
        "title": "åˆ›å»ºæ•°æ®åˆ†æå¸ˆæ™ºèƒ½ä½“",
        "description": "ä½¿ç”¨agent_factoryåˆ›å»ºä¸“ä¸šçš„æ•°æ®åˆ†ææ™ºèƒ½ä½“"
    }]
}

# åœºæ™¯2: ç”¨æˆ·æ˜ç¡®è¯·æ±‚åˆ›å»ºæ–°æ™ºèƒ½ä½“
user_input = "æˆ‘éœ€è¦ä¸€ä¸ªä¸“é—¨å¤„ç†å®¢æˆ·æœåŠ¡çš„æ™ºèƒ½ä½“"
# â†’ Coordinatoråˆ¤æ–­ä¸ºå¤æ‚ä»»åŠ¡ â†’ Plannerè®¾è®¡æ–°æ™ºèƒ½ä½“ â†’ Agent Factoryåˆ›å»º
```

#### **æ‰‹åŠ¨è§¦å‘åœºæ™¯**
```bash
# CLIç›´æ¥è°ƒç”¨agent_factoryå·¥ä½œæµ
python cli.py run-l --task-type agent_factory --message "åˆ›å»ºæ—…æ¸¸è§„åˆ’æ™ºèƒ½ä½“"
```

### 2. **æ™ºèƒ½ä½“åˆ›å»ºæµç¨‹è¯¦è§£**

#### **ç¬¬ä¸€æ­¥ï¼šéœ€æ±‚åˆ†æä¸è§£æ„**
```python
def analyze_user_requirement(user_input: str) -> dict:
    """
    éœ€æ±‚åˆ†æè¿‡ç¨‹ï¼š
    1. é¢†åŸŸè¯†åˆ«ï¼šæ—…æ¸¸ã€é‡‘èã€æ•™è‚²ã€ç¼–ç¨‹ç­‰
    2. èƒ½åŠ›éœ€æ±‚ï¼šæœç´¢ã€è®¡ç®—ã€åˆ›ä½œã€åˆ†æç­‰
    3. å·¥å…·éœ€æ±‚ï¼šAPIè°ƒç”¨ã€æ•°æ®å¤„ç†ã€æ–‡ä»¶æ“ä½œç­‰
    4. å¤æ‚åº¦è¯„ä¼°ï¼šç®€å•æŸ¥è¯¢ vs å¤æ‚è§„åˆ’
    """
    
    analysis = {
        "domain": "travel",                    # é¢†åŸŸè¯†åˆ«
        "core_capability": "itinerary_planning", # æ ¸å¿ƒèƒ½åŠ›
        "required_tools": ["maps", "weather", "booking"], # å·¥å…·éœ€æ±‚
        "complexity": "reasoning",             # å¤æ‚åº¦è¯„ä¼°
        "language": "zh-CN"                   # è¯­è¨€ç¯å¢ƒ
    }
    return analysis
```

#### **ç¬¬äºŒæ­¥ï¼šæ™ºèƒ½ä½“æ¶æ„è®¾è®¡**
```python
def design_agent_architecture(analysis: dict) -> AgentBuilder:
    """
    æ¶æ„è®¾è®¡è¿‡ç¨‹ï¼š
    1. è§’è‰²å®šä½ï¼šæ˜ç¡®æ™ºèƒ½ä½“çš„ä¸“ä¸šèº«ä»½
    2. èƒ½åŠ›æ˜ å°„ï¼šå°†éœ€æ±‚è½¬åŒ–ä¸ºå…·ä½“èƒ½åŠ›
    3. å·¥å…·é€‰æ‹©ï¼šé€‰æ‹©å¿…è¦ä¸”å¯ç”¨çš„å·¥å…·
    4. æç¤ºè¯è®¾è®¡ï¼šåˆ›å»ºä¸“ä¸šåŒ–çš„è¡Œä¸ºæŒ‡å—
    """
    
    return {
        "agent_name": "TravelPlanner",
        "agent_description": "ä¸“ä¸šçš„æ—…æ¸¸è¡Œç¨‹è§„åˆ’æ™ºèƒ½ä½“ï¼Œæä¾›ä¸ªæ€§åŒ–çš„æ—…æ¸¸æ–¹æ¡ˆè®¾è®¡",
        "thought": "ç”¨æˆ·éœ€è¦æ—…æ¸¸è§„åˆ’èƒ½åŠ›ï¼Œæ•´åˆåœ°å›¾ã€å¤©æ°”ã€é¢„è®¢ç­‰å¤šæºä¿¡æ¯...",
        "llm_type": "reasoning",               # æ¨ç†å‹LLMé€‚åˆå¤æ‚è§„åˆ’
        "selected_tools": [
            {
                "name": "tavily_tool",
                "description": "æœç´¢æ—…æ¸¸ä¿¡æ¯å’Œæ™¯ç‚¹èµ„æ–™"
            },
            {
                "name": "python_repl_tool", 
                "description": "è®¡ç®—é¢„ç®—å’Œä¼˜åŒ–è¡Œç¨‹è·¯çº¿"
            }
        ],
        "prompt": "# Role: ä¸“ä¸šæ—…æ¸¸è§„åˆ’å¸ˆ\nä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ—…æ¸¸è§„åˆ’æ™ºèƒ½ä½“..."
    }
```

#### **ç¬¬ä¸‰æ­¥ï¼šå·¥å…·é“¾éªŒè¯ä¸ç»‘å®š**
```python
async def validate_and_bind_tools(selected_tools: list[AgentTool]) -> list:
    """
    å·¥å…·éªŒè¯è¿‡ç¨‹ï¼š
    1. å¯ç”¨æ€§æ£€æŸ¥ï¼šéªŒè¯å·¥å…·æ˜¯å¦åœ¨available_toolsä¸­
    2. æƒé™éªŒè¯ï¼šç¡®è®¤å·¥å…·ä½¿ç”¨æƒé™
    3. ä¾èµ–æ£€æŸ¥ï¼šéªŒè¯å·¥å…·ä¾èµ–æ˜¯å¦æ»¡è¶³
    4. å†²çªæ£€æµ‹ï¼šæ£€æŸ¥å·¥å…·é—´æ˜¯å¦å­˜åœ¨å†²çª
    """
    
    validated_tools = []
    for tool_config in selected_tools:
        tool_name = tool_config["name"]
        
        # æ£€æŸ¥å·¥å…·å¯ç”¨æ€§
        if tool_name in agent_manager.available_tools:
            tool_instance = agent_manager.available_tools[tool_name]
            validated_tools.append(tool_instance)
            logger.info(f"Tool {tool_name} validated and bound")
        else:
            logger.warning(f"Tool {tool_name} not available, skipping")
    
    return validated_tools
```

#### **ç¬¬å››æ­¥ï¼šæ™ºèƒ½ä½“æ³¨å†Œä¸æŒä¹…åŒ–**
```python
async def register_and_persist_agent(agent_spec: AgentBuilder, tools: list):
    """
    æ³¨å†Œä¸æŒä¹…åŒ–è¿‡ç¨‹ï¼š
    1. åˆ›å»ºAgentå¯¹è±¡ï¼šæ„å»ºå®Œæ•´çš„æ™ºèƒ½ä½“é…ç½®
    2. ä¿å­˜åˆ°storeï¼šæŒä¹…åŒ–åˆ°store/agents/{name}.json
    3. è¿è¡Œæ—¶æ³¨å†Œï¼šæ·»åŠ åˆ°available_agents
    4. å›¢é˜Ÿé›†æˆï¼šæ›´æ–°TEAM_MEMBERSåˆ—è¡¨
    """
    
    # åˆ›å»ºAgentå¯¹è±¡
    agent = Agent(
        user_id=user_id,
        agent_name=agent_spec["agent_name"],
        nick_name=agent_spec["agent_name"],
        description=agent_spec["agent_description"],
        llm_type=agent_spec["llm_type"],
        selected_tools=[Tool(name=t.name, description=t.description) for t in tools],
        prompt=agent_spec["prompt"]
    )
    
    # æŒä¹…åŒ–ä¿å­˜
    await agent_manager._save_agent(agent, flush=True)
    
    # è¿è¡Œæ—¶æ³¨å†Œ
    agent_manager.available_agents[agent.agent_name] = agent
    
    # å›¢é˜Ÿé›†æˆ
    state["TEAM_MEMBERS"].append(agent.agent_name)
```

### 3. **LLMç±»å‹é€‰æ‹©ç­–ç•¥**

#### **LLMç±»å‹æ˜ å°„è¡¨**
```python
# src/llm/agents.py: AGENT_LLM_MAP
LLM_SELECTION_STRATEGY = {
    "basic": {
        "é€‚ç”¨åœºæ™¯": ["ç®€å•æŸ¥è¯¢", "ä¿¡æ¯æ£€ç´¢", "æ–‡æœ¬ç”Ÿæˆ"],
        "ç‰¹ç‚¹": ["å“åº”å¿«é€Ÿ", "æˆæœ¬è¾ƒä½", "é€‚åˆæ ‡å‡†ä»»åŠ¡"],
        "ç¤ºä¾‹æ™ºèƒ½ä½“": ["å®¢æœåŠ©æ‰‹", "ä¿¡æ¯æŸ¥è¯¢å‘˜", "å†…å®¹ç¼–è¾‘"]
    },
    "reasoning": {
        "é€‚ç”¨åœºæ™¯": ["å¤æ‚æ¨ç†", "å¤šæ­¥è§„åˆ’", "é€»è¾‘åˆ†æ"],
        "ç‰¹ç‚¹": ["æ·±åº¦æ€è€ƒ", "é€»è¾‘ä¸¥å¯†", "é€‚åˆå¤æ‚ä»»åŠ¡"],
        "ç¤ºä¾‹æ™ºèƒ½ä½“": ["æŠ•èµ„åˆ†æå¸ˆ", "æ—…æ¸¸è§„åˆ’å¸ˆ", "é¡¹ç›®ç»ç†"]
    },
    "code": {
        "é€‚ç”¨åœºæ™¯": ["ç¼–ç¨‹ä»»åŠ¡", "ä»£ç ç”Ÿæˆ", "æŠ€æœ¯åˆ†æ"],
        "ç‰¹ç‚¹": ["ä»£ç ä¸“ç²¾", "æŠ€æœ¯ç†è§£", "ç¼–ç¨‹æœ€ä½³å®è·µ"],
        "ç¤ºä¾‹æ™ºèƒ½ä½“": ["è½¯ä»¶å·¥ç¨‹å¸ˆ", "æ•°æ®ç§‘å­¦å®¶", "ç®—æ³•ä¸“å®¶"]
    },
    "vision": {
        "é€‚ç”¨åœºæ™¯": ["å›¾åƒåˆ†æ", "è§†è§‰ç†è§£", "å¤šæ¨¡æ€ä»»åŠ¡"],
        "ç‰¹ç‚¹": ["è§†è§‰æ„ŸçŸ¥", "å›¾æ–‡ç»“åˆ", "å¤šæ¨¡æ€å¤„ç†"],
        "ç¤ºä¾‹æ™ºèƒ½ä½“": ["å›¾åƒåˆ†æå¸ˆ", "è®¾è®¡å¸ˆ", "åŒ»ç–—å½±åƒä¸“å®¶"]
    }
}

def select_llm_type(task_complexity: str, domain: str, capabilities: list[str]) -> str:
    """LLMç±»å‹æ™ºèƒ½é€‰æ‹©ç®—æ³•"""
    
    # ä»£ç ç›¸å…³ä»»åŠ¡
    if any(keyword in capabilities for keyword in ["ç¼–ç¨‹", "ä»£ç ", "ç®—æ³•", "æ•°æ®åˆ†æ"]):
        return "code"
    
    # è§†è§‰ç›¸å…³ä»»åŠ¡
    if any(keyword in capabilities for keyword in ["å›¾åƒ", "è§†è§‰", "è¯†åˆ«", "å¤šæ¨¡æ€"]):
        return "vision"
    
    # å¤æ‚æ¨ç†ä»»åŠ¡
    if task_complexity in ["complex", "multi-step"] or len(capabilities) > 3:
        return "reasoning"
    
    # é»˜è®¤åŸºç¡€ç±»å‹
    return "basic"
```

### 4. **é”™è¯¯å¤„ç†ä¸å®¹é”™æœºåˆ¶**

#### **å¤šå±‚æ¬¡é”™è¯¯å¤„ç†**
```python
async def agent_factory_with_error_handling(state: State):
    """å¸¦å®Œæ•´é”™è¯¯å¤„ç†çš„agent_factoryå®ç°"""
    
    try:
        # === æç¤ºè¯åº”ç”¨é˜¶æ®µ ===
        messages = apply_prompt_template("agent_factory", state)
        
        # === LLMè°ƒç”¨é˜¶æ®µ ===
        agent_spec = await (
            get_llm_by_type(AGENT_LLM_MAP["agent_factory"])
            .with_structured_output(AgentBuilder)
            .ainvoke(messages)
        )
        
        # === é…ç½®éªŒè¯é˜¶æ®µ ===
        if not agent_spec.get("agent_name"):
            raise ValueError("Agent name is required")
        
        if agent_spec["agent_name"] == "agent_factory":
            raise ValueError("Agent name cannot be 'agent_factory'")
        
        # === å·¥å…·éªŒè¯é˜¶æ®µ ===
        tools = []
        failed_tools = []
        
        for tool_config in agent_spec["selected_tools"]:
            if agent_manager.available_tools.get(tool_config["name"]):
                tools.append(agent_manager.available_tools[tool_config["name"]])
            else:
                failed_tools.append(tool_config["name"])
        
        if failed_tools:
            logger.warning(f"Tools not available: {failed_tools}")
        
        if not tools:
            raise ValueError("No valid tools selected for agent")
        
        # === æ™ºèƒ½ä½“åˆ›å»ºé˜¶æ®µ ===
        await agent_manager._create_agent_by_prebuilt(
            user_id=state["user_id"],
            name=agent_spec["agent_name"],
            nick_name=agent_spec["agent_name"],
            llm_type=agent_spec["llm_type"],
            tools=tools,
            prompt=agent_spec["prompt"],
            description=agent_spec["agent_description"],
        )
        
        return create_success_response(agent_spec)
        
    except ValueError as e:
        logger.error(f"Configuration error in agent factory: {e}")
        return create_error_response(f"é…ç½®é”™è¯¯: {e}")
        
    except KeyError as e:
        logger.error(f"Missing required field: {e}")
        return create_error_response(f"ç¼ºå°‘å¿…è¦å­—æ®µ: {e}")
        
    except Exception as e:
        logger.error(f"Unexpected error in agent factory: {e}")
        return create_error_response(f"æ™ºèƒ½ä½“åˆ›å»ºå¤±è´¥: {e}")

def create_success_response(agent_spec: AgentBuilder):
    """åˆ›å»ºæˆåŠŸå“åº”"""
    return Command(
        update={
            "messages": [{
                "content": f"âœ… æ™ºèƒ½ä½“ {agent_spec['agent_name']} åˆ›å»ºæˆåŠŸ!",
                "tool": "agent_factory",
                "role": "assistant",
            }],
            "new_agent_name": agent_spec["agent_name"],
            "agent_name": "agent_factory",
        },
        goto="publisher",
    )

def create_error_response(error_message: str):
    """åˆ›å»ºé”™è¯¯å“åº”"""
    return Command(
        update={
            "messages": [{
                "content": f"âŒ æ™ºèƒ½ä½“åˆ›å»ºå¤±è´¥: {error_message}",
                "tool": "agent_factory",
                "role": "assistant",
            }],
            "agent_name": "agent_factory",
            "error": error_message,
        },
        goto="__end__",
    )
```

---

## ğŸ¯ æ—…æ¸¸æ™ºèƒ½ä½“å®šåˆ¶åŒ–å®ç°æ–¹æ¡ˆ

### 1. **æ—…æ¸¸é¢†åŸŸAgent Factoryå¢å¼ºç­–ç•¥**

#### **åˆ›å»ºæ—…æ¸¸ä¸“ç”¨Agent Factory**
```python
# src/prompts/travel_agent_factory.md
"""
---
CURRENT_TIME: <<CURRENT_TIME>>
---
# Role: æ—…æ¸¸æ™ºèƒ½ä½“ä¸“å®¶æ„å»ºå¸ˆ

You are `TravelAgentFactory`, a specialized AI agent builder focused on creating 
sophisticated travel and tourism agents. Your expertise lies in understanding travel 
domain requirements and building agents with comprehensive travel capabilities.

# æ—…æ¸¸é¢†åŸŸä¸“ä¸šçŸ¥è¯†åº“
## æ ¸å¿ƒèƒ½åŠ›åŸŸ
- **è¡Œç¨‹è§„åˆ’**: è·¯çº¿ä¼˜åŒ–ã€æ—¶é—´å®‰æ’ã€æ™¯ç‚¹ä¸²è”
- **é¢„ç®—ç®¡ç†**: æˆæœ¬æ§åˆ¶ã€ä»·æ ¼æ¯”è¾ƒã€ä¼˜æƒ å‘ç°  
- **åœ°ç†æ™ºèƒ½**: åœ°å›¾å¯¼èˆªã€äº¤é€šè§„åˆ’ã€åœ°ç†çº¦æŸ
- **æ–‡åŒ–é€‚åº”**: æœ¬åœ°ä¹ ä¿—ã€è¯­è¨€æ”¯æŒã€æ–‡åŒ–ä½“éªŒ
- **é£é™©ç®¡ç†**: å®‰å…¨è¯„ä¼°ã€å¤©æ°”åº”å¯¹ã€åº”æ€¥é¢„æ¡ˆ
- **ä¸ªæ€§åŒ–**: åå¥½åŒ¹é…ã€ç¾¤ä½“åè°ƒã€ç‰¹æ®Šéœ€æ±‚

## ä¸“ä¸šå·¥å…·ç”Ÿæ€
### åœ°ç†ä¸å¯¼èˆªå·¥å…·
- `maps_direction_transit_integrated`: ç»¼åˆäº¤é€šè·¯çº¿è§„åˆ’
- `geographic_poi_search`: åœ°ç†å…´è¶£ç‚¹æœç´¢
- `distance_time_calculator`: è·ç¦»æ—¶é—´è®¡ç®—å™¨

### é¢„è®¢ä¸ä»·æ ¼å·¥å…·  
- `hotel_search_and_booking`: é…’åº—æœç´¢é¢„è®¢æœåŠ¡
- `flight_search_comparison`: èˆªç­æœç´¢æ¯”ä»·ç³»ç»Ÿ
- `attraction_ticket_booking`: æ™¯ç‚¹é—¨ç¥¨é¢„è®¢å¹³å°

### ä¿¡æ¯ä¸å†³ç­–å·¥å…·
- `weather_forecast_travel`: æ—…æ¸¸ä¸“ç”¨å¤©æ°”é¢„æŠ¥
- `local_events_finder`: å½“åœ°æ´»åŠ¨äº‹ä»¶å‘ç°
- `currency_converter_realtime`: å®æ—¶æ±‡ç‡è½¬æ¢
- `visa_requirements_checker`: ç­¾è¯è¦æ±‚æŸ¥è¯¢

### å†…å®¹ä¸ä½“éªŒå·¥å…·
- `restaurant_recommendations`: é¤å…æ¨èç³»ç»Ÿ
- `cultural_guide_generator`: æ–‡åŒ–æŒ‡å—ç”Ÿæˆå™¨
- `photo_spot_identifier`: æ‹ç…§ç‚¹è¯†åˆ«æ¨è

# æ—…æ¸¸æ™ºèƒ½ä½“è®¾è®¡æ¨¡å¼

## æ¨¡å¼1: ç»¼åˆè§„åˆ’å¸ˆ (Comprehensive Planner)
- **é€‚ç”¨åœºæ™¯**: å®Œæ•´æ—…è¡Œè§„åˆ’ã€å¤šç›®çš„åœ°è¡Œç¨‹
- **æ ¸å¿ƒå·¥å…·**: åœ°å›¾å¯¼èˆª + é¢„è®¢æœåŠ¡ + å¤©æ°”ä¿¡æ¯
- **LLMç±»å‹**: reasoning (éœ€è¦å¤æ‚çš„é€»è¾‘æ¨ç†)

## æ¨¡å¼2: ä¸“ä¸šé¡¾é—® (Specialized Consultant)  
- **é€‚ç”¨åœºæ™¯**: ç‰¹å®šé¢†åŸŸå’¨è¯¢(ç¾é£Ÿã€æ–‡åŒ–ã€æ‘„å½±)
- **æ ¸å¿ƒå·¥å…·**: é¢†åŸŸä¸“ç”¨å·¥å…· + æœç´¢å¼•æ“
- **LLMç±»å‹**: basic (é¢†åŸŸçŸ¥è¯†åº”ç”¨)

## æ¨¡å¼3: å®æ—¶åŠ©æ‰‹ (Real-time Assistant)
- **é€‚ç”¨åœºæ™¯**: æ—…è¡Œä¸­çš„å®æ—¶æ”¯æŒå’Œé—®é¢˜è§£å†³
- **æ ¸å¿ƒå·¥å…·**: å®æ—¶ä¿¡æ¯ + åº”æ€¥æœåŠ¡ + é€šè®¯å·¥å…·
- **LLMç±»å‹**: basic (å¿«é€Ÿå“åº”)

# æç¤ºè¯æ¨¡æ¿å¢å¼º
é’ˆå¯¹æ—…æ¸¸æ™ºèƒ½ä½“ï¼Œæç¤ºè¯éœ€è¦åŒ…å«ï¼š

## åœ°ç†ç©ºé—´æ„è¯†
"ä½ å…·å¤‡å¼ºå¤§çš„åœ°ç†ç©ºé—´æ¨ç†èƒ½åŠ›ï¼Œèƒ½å¤Ÿï¼š
- ç†è§£åœ°ç†ä½ç½®å…³ç³»å’Œç©ºé—´è·ç¦»
- è€ƒè™‘äº¤é€šæ–¹å¼å’Œæ—¶é—´æˆæœ¬
- è¯†åˆ«åœ°ç†å’Œæ°”å€™çº¦æŸæ¡ä»¶"

## æ–‡åŒ–æ•æ„Ÿæ€§
"ä½ å…·å¤‡è·¨æ–‡åŒ–ç†è§£èƒ½åŠ›ï¼Œèƒ½å¤Ÿï¼š
- å°Šé‡å½“åœ°æ–‡åŒ–ä¹ ä¿—å’Œä¼ ç»Ÿ
- æä¾›æ–‡åŒ–èƒŒæ™¯å’Œå†å²ä»‹ç»  
- è¯†åˆ«å’Œé¿å…æ–‡åŒ–å†²çª"

## é¢„ç®—ä¼˜åŒ–æ€ç»´
"ä½ å…·å¤‡é¢„ç®—ä¼˜åŒ–èƒ½åŠ›ï¼Œèƒ½å¤Ÿï¼š
- åœ¨é¢„ç®—çº¦æŸä¸‹æœ€å¤§åŒ–æ—…è¡Œä½“éªŒ
- å‘ç°ä¼˜æƒ å’Œçœé’±æœºä¼š
- å¹³è¡¡æˆæœ¬ä¸ä½“éªŒè´¨é‡"

# è¾“å‡ºè¦æ±‚
ä¸¥æ ¼æŒ‰ç…§AgentBuilderæ¥å£è¾“å‡ºï¼Œä½†å¢åŠ æ—…æ¸¸ä¸“ç”¨å­—æ®µï¼š

```ts
interface TravelAgentBuilder extends AgentBuilder {
  agent_name: string;
  agent_description: string;
  thought: string;
  llm_type: "basic" | "reasoning" | "vision";
  selected_tools: TravelTool[];
  prompt: string;
  
  // æ—…æ¸¸ä¸“ç”¨æ‰©å±•å­—æ®µ
  travel_domain: "planning" | "consulting" | "assistance";
  geographic_scope: "local" | "domestic" | "international";
  specialization: string[];  // ["budget", "luxury", "adventure", "culture", "family"]
  language_support: string[]; // ["zh-CN", "en-US", "ja-JP"]
}
```
"""
```

#### **æ—…æ¸¸å·¥å…·é€‰æ‹©å¢å¼ºé€»è¾‘**
```python
# src/workflow/travel_agent_factory.py

TRAVEL_TOOL_CATEGORIES = {
    "geography": [
        "maps_direction_transit_integrated",
        "geographic_poi_search", 
        "distance_time_calculator",
        "elevation_terrain_analyzer"
    ],
    "booking": [
        "hotel_search_and_booking",
        "flight_search_comparison",
        "attraction_ticket_booking",
        "car_rental_service"
    ],
    "information": [
        "weather_forecast_travel",
        "local_events_finder", 
        "currency_converter_realtime",
        "visa_requirements_checker"
    ],
    "experience": [
        "restaurant_recommendations",
        "cultural_guide_generator",
        "photo_spot_identifier",
        "local_transport_guide"
    ]
}

class TravelAgentFactory:
    """æ—…æ¸¸æ™ºèƒ½ä½“ä¸“ç”¨å·¥å‚"""
    
    def __init__(self):
        self.tool_selector = TravelToolSelector()
        self.prompt_generator = TravelPromptGenerator()
        self.llm_optimizer = TravelLLMOptimizer()
    
    async def create_travel_agent(self, requirement: TravelAgentRequirement) -> AgentBuilder:
        """åˆ›å»ºæ—…æ¸¸ä¸“ç”¨æ™ºèƒ½ä½“"""
        
        # 1. åˆ†ææ—…æ¸¸éœ€æ±‚ç±»å‹
        travel_type = self.analyze_travel_type(requirement)
        
        # 2. æ™ºèƒ½é€‰æ‹©å·¥å…·ç»„åˆ
        selected_tools = self.tool_selector.select_optimal_tools(
            travel_type=travel_type,
            geographic_scope=requirement.geographic_scope,
            budget_level=requirement.budget_level,
            traveler_profile=requirement.traveler_profile
        )
        
        # 3. ç”Ÿæˆä¸“ä¸šåŒ–æç¤ºè¯
        prompt = self.prompt_generator.generate_travel_prompt(
            agent_role=requirement.role,
            specialization=requirement.specialization,
            cultural_context=requirement.cultural_context,
            service_level=requirement.service_level
        )
        
        # 4. ä¼˜åŒ–LLMé€‰æ‹©
        llm_type = self.llm_optimizer.select_optimal_llm(
            complexity=requirement.task_complexity,
            real_time_needs=requirement.real_time_needs,
            reasoning_depth=requirement.reasoning_depth
        )
        
        return AgentBuilder(
            agent_name=requirement.agent_name,
            agent_description=requirement.description,
            thought=f"åŸºäº{travel_type}éœ€æ±‚ï¼Œè®¾è®¡ä¸“ä¸šæ—…æ¸¸æ™ºèƒ½ä½“ï¼Œæ•´åˆ{len(selected_tools)}ä¸ªä¸“ç”¨å·¥å…·",
            llm_type=llm_type,
            selected_tools=selected_tools,
            prompt=prompt
        )

class TravelToolSelector:
    """æ—…æ¸¸å·¥å…·æ™ºèƒ½é€‰æ‹©å™¨"""
    
    def select_optimal_tools(self, travel_type: str, geographic_scope: str, 
                           budget_level: str, traveler_profile: dict) -> list[AgentTool]:
        """åŸºäºéœ€æ±‚æ™ºèƒ½é€‰æ‹©å·¥å…·ç»„åˆ"""
        
        tools = []
        
        # åŸºç¡€å·¥å…·ï¼ˆæ‰€æœ‰æ—…æ¸¸æ™ºèƒ½ä½“å¿…å¤‡ï¼‰
        tools.extend([
            AgentTool(name="tavily_tool", description="æœç´¢æ—…æ¸¸ä¿¡æ¯å’Œå®æ—¶èµ„è®¯"),
            AgentTool(name="python_repl_tool", description="æ‰§è¡Œè®¡ç®—å’Œæ•°æ®åˆ†æ")
        ])
        
        # åœ°ç†å·¥å…·ï¼ˆæ ¹æ®åœ°ç†èŒƒå›´é€‰æ‹©ï¼‰
        if geographic_scope in ["domestic", "international"]:
            tools.extend([
                AgentTool(name="maps_direction_transit_integrated", description="ç»¼åˆäº¤é€šå¯¼èˆªè§„åˆ’"),
                AgentTool(name="distance_time_calculator", description="è·ç¦»æ—¶é—´è®¡ç®—")
            ])
        
        # é¢„è®¢å·¥å…·ï¼ˆæ ¹æ®é¢„ç®—ç­‰çº§é€‰æ‹©ï¼‰
        if budget_level in ["medium", "high"]:
            tools.extend([
                AgentTool(name="hotel_search_and_booking", description="é…’åº—æœç´¢é¢„è®¢"),
                AgentTool(name="flight_search_comparison", description="èˆªç­æ¯”ä»·é¢„è®¢")
            ])
        
        # ä¸“ä¸šå·¥å…·ï¼ˆæ ¹æ®æ—…è¡Œè€…ç”»åƒé€‰æ‹©ï¼‰
        if traveler_profile.get("food_lover"):
            tools.append(AgentTool(name="restaurant_recommendations", description="é¤å…æ¨è"))
        
        if traveler_profile.get("culture_seeker"):
            tools.append(AgentTool(name="cultural_guide_generator", description="æ–‡åŒ–å¯¼è§ˆ"))
        
        if traveler_profile.get("photographer"):
            tools.append(AgentTool(name="photo_spot_identifier", description="æ‘„å½±ç‚¹æ¨è"))
        
        return tools

class TravelPromptGenerator:
    """æ—…æ¸¸æç¤ºè¯ç”Ÿæˆå™¨"""
    
    def generate_travel_prompt(self, agent_role: str, specialization: list[str],
                             cultural_context: str, service_level: str) -> str:
        """ç”Ÿæˆæ—…æ¸¸ä¸“ç”¨æç¤ºè¯"""
        
        base_prompt = f"""
# Role: {agent_role}
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„{agent_role}ï¼Œå…·å¤‡ä¸°å¯Œçš„æ—…æ¸¸è¡Œä¸šç»éªŒå’Œæ·±åšçš„ä¸“ä¸šçŸ¥è¯†ã€‚

# ä¸“ä¸šèƒ½åŠ›
ä½ çš„æ ¸å¿ƒä¸“é•¿åŒ…æ‹¬ï¼š{', '.join(specialization)}

# åœ°ç†å’Œæ–‡åŒ–æ„è¯†
- **åœ°ç†æ™ºèƒ½**: ä½ å…·å¤‡å¼ºå¤§çš„åœ°ç†ç©ºé—´æ¨ç†èƒ½åŠ›ï¼Œèƒ½å¤Ÿç†è§£ä½ç½®å…³ç³»ã€äº¤é€šè¿æ¥å’Œåœ°ç†çº¦æŸ
- **æ–‡åŒ–æ•æ„Ÿ**: ä½ æ·±åº¦ç†è§£{cultural_context}çš„æ–‡åŒ–èƒŒæ™¯ï¼Œå°Šé‡å½“åœ°ä¹ ä¿—å¹¶èƒ½æä¾›æ–‡åŒ–æ´å¯Ÿ
- **æ—¶é—´ç®¡ç†**: ä½ èƒ½å¤Ÿåˆç†å®‰æ’è¡Œç¨‹æ—¶é—´ï¼Œè€ƒè™‘äº¤é€šã€æ’é˜Ÿã€ä¼‘æ¯ç­‰å®é™…å› ç´ 

# æœåŠ¡æ ‡å‡†
ä½ çš„æœåŠ¡æ°´å‡†ä¸º{service_level}ï¼Œè¿™æ„å‘³ç€ï¼š
- æä¾›è¯¦ç»†ã€å‡†ç¡®ã€å®ç”¨çš„æ—…æ¸¸å»ºè®®
- è€ƒè™‘ç”¨æˆ·çš„é¢„ç®—ã€æ—¶é—´ã€åå¥½ç­‰ä¸ªæ€§åŒ–éœ€æ±‚
- ä¸»åŠ¨è¯†åˆ«å’Œè§„é¿æ½œåœ¨çš„æ—…è¡Œé£é™©
- æä¾›backupæ–¹æ¡ˆå’Œåº”æ€¥å»ºè®®

# å·¥ä½œæµç¨‹
1. **éœ€æ±‚åˆ†æ**: ä»”ç»†åˆ†æç”¨æˆ·çš„æ—…è¡Œéœ€æ±‚ã€çº¦æŸæ¡ä»¶å’Œåå¥½
2. **ä¿¡æ¯æ”¶é›†**: ä½¿ç”¨æœç´¢å·¥å…·è·å–æœ€æ–°ã€å‡†ç¡®çš„æ—…æ¸¸ä¿¡æ¯
3. **æ–¹æ¡ˆè®¾è®¡**: åŸºäºæ”¶é›†çš„ä¿¡æ¯è®¾è®¡ä¸ªæ€§åŒ–çš„æ—…è¡Œæ–¹æ¡ˆ
4. **ä¼˜åŒ–è°ƒæ•´**: è€ƒè™‘å®é™…çº¦æŸï¼Œä¼˜åŒ–æ–¹æ¡ˆçš„å¯è¡Œæ€§å’Œä½“éªŒ
5. **è¯¦ç»†è¾“å‡º**: æä¾›ç»“æ„åŒ–ã€å¯æ‰§è¡Œçš„æ—…è¡Œè®¡åˆ’

# è¾“å‡ºæ ¼å¼
è¯·å§‹ç»ˆä»¥ç»“æ„åŒ–çš„æ–¹å¼è¾“å‡ºï¼ŒåŒ…æ‹¬ï¼š
- **è¡Œç¨‹æ¦‚è§ˆ**: æ€»ä½“å®‰æ’å’Œäº®ç‚¹
- **è¯¦ç»†è®¡åˆ’**: æŒ‰å¤©åˆ†è§£çš„å…·ä½“å®‰æ’
- **é¢„ç®—ä¼°ç®—**: å„é¡¹è´¹ç”¨çš„è¯¦ç»†åˆ†è§£
- **æ³¨æ„äº‹é¡¹**: é‡è¦æé†’å’Œåº”æ€¥ä¿¡æ¯
- **å¤‡é€‰æ–¹æ¡ˆ**: å¤©æ°”æˆ–å…¶ä»–å› ç´ çš„æ›¿ä»£é€‰æ‹©

# è´¨é‡æ ‡å‡†
- **å‡†ç¡®æ€§**: æ‰€æœ‰ä¿¡æ¯å¿…é¡»å‡†ç¡®ã€æœ€æ–°
- **å®ç”¨æ€§**: æä¾›å¯å®é™…æ‰§è¡Œçš„å…·ä½“å»ºè®®
- **ä¸ªæ€§åŒ–**: å……åˆ†è€ƒè™‘ç”¨æˆ·çš„ä¸ªäººæƒ…å†µå’Œåå¥½
- **å®Œæ•´æ€§**: è€ƒè™‘æ—…è¡Œçš„å„ä¸ªæ–¹é¢ï¼Œä¸é—æ¼é‡è¦ç»†èŠ‚
"""
        
        return base_prompt
```

### 2. **å…·ä½“å®ç°æ¡ˆä¾‹ï¼šåˆ›å»ºä¸“ä¸šæ—…æ¸¸è§„åˆ’å¸ˆ**

#### **æ¡ˆä¾‹éœ€æ±‚**
```python
# ç”¨æˆ·éœ€æ±‚: åˆ›å»ºä¸“ä¸šçš„åŒ—äº¬ä¸‰æ—¥æ¸¸è§„åˆ’æ™ºèƒ½ä½“
user_requirement = {
    "agent_name": "BeijingTravelExpert",
    "role": "åŒ—äº¬ä¸‰æ—¥æ¸¸ä¸“ä¸šè§„åˆ’å¸ˆ", 
    "capabilities": [
        "æ™¯ç‚¹è·¯çº¿ä¼˜åŒ–",
        "äº¤é€šæ–¹æ¡ˆè®¾è®¡", 
        "ç¾é£Ÿæ¨è",
        "æ–‡åŒ–ä½“éªŒè§„åˆ’",
        "é¢„ç®—æ§åˆ¶"
    ],
    "geographic_scope": "Beijing",
    "target_traveler": "æ–‡åŒ–çˆ±å¥½è€…ã€ç¾é£Ÿæ¢ç´¢è€…",
    "budget_range": "2000-5000 RMB",
    "special_requirements": ["é¿å¼€äººæµé«˜å³°", "åŒ…å«ä¼ ç»Ÿæ–‡åŒ–ä½“éªŒ"]
}
```

#### **Agent Factoryç”Ÿæˆé…ç½®**
```json
{
  "agent_name": "BeijingTravelExpert",
  "agent_description": "ä¸“ä¸šçš„åŒ—äº¬æ–‡åŒ–æ—…æ¸¸è§„åˆ’æ™ºèƒ½ä½“ï¼Œæä¾›æ·±åº¦æ–‡åŒ–ä½“éªŒå’Œç¾é£Ÿæ¢ç´¢çš„ä¸ªæ€§åŒ–ä¸‰æ—¥æ¸¸æ–¹æ¡ˆ",
  "thought": "ç”¨æˆ·éœ€è¦ä¸“ä¸šçš„åŒ—äº¬æ—…æ¸¸è§„åˆ’èƒ½åŠ›ã€‚åŒ—äº¬ä½œä¸ºå†å²æ–‡åŒ–ååŸï¼Œéœ€è¦æ·±åº¦çš„æ–‡åŒ–ç†è§£å’Œæœ¬åœ°çŸ¥è¯†ã€‚è€ƒè™‘åˆ°ç”¨æˆ·åå¥½æ–‡åŒ–ä½“éªŒå’Œç¾é£Ÿï¼Œéœ€è¦æ•´åˆåœ°å›¾å¯¼èˆªã€é¤å…æ¨èã€æ–‡åŒ–å¯¼è§ˆç­‰å·¥å…·ã€‚é¢„ç®—æ§åˆ¶å’Œäººæµé¿å¼€éœ€è¦æ•°æ®åˆ†æèƒ½åŠ›ã€‚",
  "llm_type": "reasoning",
  "selected_tools": [
    {
      "name": "tavily_tool",
      "description": "æœç´¢åŒ—äº¬æœ€æ–°æ—…æ¸¸ä¿¡æ¯ã€æ´»åŠ¨èµ„è®¯å’Œå®æ—¶çŠ¶å†µ"
    },
    {
      "name": "maps_direction_transit_integrated", 
      "description": "åŒ—äº¬åœ°é“ã€å…¬äº¤ã€æ­¥è¡Œè·¯çº¿ç»¼åˆè§„åˆ’"
    },
    {
      "name": "restaurant_recommendations",
      "description": "åŒ—äº¬ç‰¹è‰²ç¾é£Ÿå’Œé¤å…æ¨èç³»ç»Ÿ"
    },
    {
      "name": "cultural_guide_generator",
      "description": "åŒ—äº¬å†å²æ–‡åŒ–æ™¯ç‚¹æ·±åº¦å¯¼è§ˆç”Ÿæˆ"
    },
    {
      "name": "python_repl_tool",
      "description": "é¢„ç®—è®¡ç®—ã€è·¯çº¿ä¼˜åŒ–å’Œæ•°æ®åˆ†æ"
    },
    {
      "name": "weather_forecast_travel",
      "description": "åŒ—äº¬å¤©æ°”é¢„æŠ¥ï¼Œä¼˜åŒ–å®¤å†…å¤–æ´»åŠ¨å®‰æ’"
    }
  ],
  "prompt": "# Role: åŒ—äº¬æ–‡åŒ–æ—…æ¸¸ä¸“å®¶\nä½ æ˜¯ä¸€ä½æ·±è°™åŒ—äº¬å†å²æ–‡åŒ–çš„ä¸“ä¸šæ—…æ¸¸è§„åˆ’å¸ˆï¼Œä¸“æ³¨äºä¸ºæ¸¸å®¢è®¾è®¡æ·±åº¦çš„æ–‡åŒ–ä½“éªŒå’Œç¾é£Ÿæ¢ç´¢ä¹‹æ—…ã€‚ä½ å…·å¤‡ä¸°å¯Œçš„åŒ—äº¬æœ¬åœ°çŸ¥è¯†ï¼Œäº†è§£å„ä¸ªæ™¯ç‚¹çš„å†å²èƒŒæ™¯ã€æœ€ä½³æ¸¸è§ˆæ—¶é—´ã€ä»¥åŠå¦‚ä½•é¿å¼€äººæµé«˜å³°ã€‚\n\n# ä¸“ä¸šèƒ½åŠ›\n- **æ–‡åŒ–æ·±åº¦**: æ·±å…¥äº†è§£åŒ—äº¬çš„å†å²æ–‡åŒ–ï¼Œèƒ½å¤Ÿè®²è¿°æ™¯ç‚¹èƒŒåçš„æ•…äº‹\n- **è·¯çº¿ä¼˜åŒ–**: åŸºäºåœ°ç†ä½ç½®å’Œæ—¶é—´å®‰æ’ï¼Œè®¾è®¡æœ€ä¼˜çš„æ¸¸è§ˆè·¯çº¿\n- **ç¾é£Ÿä¸“é•¿**: ç†ŸçŸ¥åŒ—äº¬ä¼ ç»Ÿç¾é£Ÿå’Œç°ä»£åˆ›æ–°é¤å…\n- **äººæµåˆ†æ**: æŒæ¡å„æ™¯ç‚¹çš„äººæµè§„å¾‹ï¼Œå¸®åŠ©æ¸¸å®¢é¿å¼€æ‹¥æŒ¤æ—¶æ®µ\n- **é¢„ç®—ç®¡ç†**: ç²¾ç¡®æ§åˆ¶æ—…è¡Œæˆæœ¬ï¼Œåœ¨é¢„ç®—å†…æœ€å¤§åŒ–ä½“éªŒä»·å€¼\n\n# å·¥ä½œæµç¨‹\n1. **éœ€æ±‚åˆ†æ**: äº†è§£æ¸¸å®¢çš„æ—¶é—´å®‰æ’ã€é¢„ç®—èŒƒå›´ã€å…´è¶£åå¥½å’Œç‰¹æ®Šè¦æ±‚\n2. **ä¿¡æ¯æœé›†**: æŸ¥è¯¢æœ€æ–°çš„æ™¯ç‚¹ä¿¡æ¯ã€å¤©æ°”çŠ¶å†µã€æ´»åŠ¨èµ„è®¯\n3. **è·¯çº¿è®¾è®¡**: ä½¿ç”¨åœ°å›¾å·¥å…·è§„åˆ’æœ€ä¼˜çš„äº¤é€šè·¯çº¿å’Œæ—¶é—´å®‰æ’\n4. **æ–‡åŒ–æ•´åˆ**: ä¸ºæ¯ä¸ªæ™¯ç‚¹å‡†å¤‡æ–‡åŒ–èƒŒæ™¯ä»‹ç»å’Œæ·±åº¦ä½“éªŒå»ºè®®\n5. **ç¾é£Ÿè§„åˆ’**: æ¨èæ²¿é€”çš„ç‰¹è‰²é¤å…å’Œå°åƒï¼Œèå…¥è¡Œç¨‹å®‰æ’\n6. **é¢„ç®—ä¼˜åŒ–**: è®¡ç®—è¯¦ç»†è´¹ç”¨ï¼Œæä¾›ä¸åŒä»·ä½çš„é€‰æ‹©æ–¹æ¡ˆ\n7. **åº”æ€¥é¢„æ¡ˆ**: è€ƒè™‘å¤©æ°”ç­‰å› ç´ ï¼Œå‡†å¤‡å¤‡é€‰æ–¹æ¡ˆ\n\n# è¾“å‡ºæ ‡å‡†\n## è¡Œç¨‹æ¦‚è§ˆ\n- ä¸‰æ—¥è¡Œç¨‹ä¸»é¢˜å’Œäº®ç‚¹æ€»ç»“\n- æ¯æ—¥æ ¸å¿ƒä½“éªŒå’Œæ—¶é—´åˆ†é…\n- æ€»ä½“é¢„ç®—èŒƒå›´å’Œä¸»è¦æ”¯å‡ºé¡¹ç›®\n\n## è¯¦ç»†è®¡åˆ’ \n- **ç¬¬ä¸€å¤©**: æ•…å®«ã€å¤©å®‰é—¨å¹¿åœºæ–‡åŒ–æ·±åº¦æ¸¸\n- **ç¬¬äºŒå¤©**: é•¿åŸä½“éªŒ + èƒ¡åŒæ–‡åŒ–æ¢ç´¢\n- **ç¬¬ä¸‰å¤©**: é¢å’Œå›­ã€åœ†æ˜å›­å†å²æ–‡åŒ–æ¸¸\n\n## ç¾é£Ÿæ¨è\n- æ¯é¤å…·ä½“é¤å…æ¨èå’Œæ‹›ç‰Œèœ\n- ç‰¹è‰²å°åƒä½“éªŒåœ°ç‚¹å’Œæ—¶é—´\n- é¢„ç®—åˆ†é…å’Œæ€§ä»·æ¯”åˆ†æ\n\n## æ–‡åŒ–è§£è¯»\n- æ¯ä¸ªæ™¯ç‚¹çš„å†å²èƒŒæ™¯å’Œæ–‡åŒ–æ„ä¹‰\n- æœ€ä½³æ‹ç…§ç‚¹å’Œæ¸¸è§ˆé¡ºåº\n- æ·±åº¦ä½“éªŒå»ºè®®å’Œæ³¨æ„äº‹é¡¹\n\n## å®ç”¨ä¿¡æ¯\n- è¯¦ç»†äº¤é€šè·¯çº¿å’Œç”¨æ—¶\n- é—¨ç¥¨ä»·æ ¼å’Œé¢„è®¢å»ºè®®  \n- æœ€ä½³æ¸¸è§ˆæ—¶é—´å’Œé¿å³°ç­–ç•¥\n- å¤©æ°”åº”å¯¹å’Œå¤‡é€‰æ–¹æ¡ˆ\n\n# æœåŠ¡æ‰¿è¯º\n- æä¾›å‡†ç¡®ã€æœ€æ–°çš„æ—…æ¸¸ä¿¡æ¯\n- ç¡®ä¿è¡Œç¨‹çš„å¯æ‰§è¡Œæ€§å’Œæ—¶é—´åˆç†æ€§\n- åœ¨é¢„ç®—çº¦æŸå†…æœ€å¤§åŒ–æ–‡åŒ–ä½“éªŒä»·å€¼\n- è´´å¿ƒè€ƒè™‘æ¸¸å®¢çš„ä½“åŠ›å’Œå…´è¶£åˆ†å¸ƒ\n- æä¾›7x24å°æ—¶å¯å‚è€ƒçš„è¯¦ç»†æŒ‡å—"
}
```

### 3. **æ—…æ¸¸Agent Factoryå®Œæ•´éƒ¨ç½²æ–¹æ¡ˆ**

#### **ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºæ—…æ¸¸ä¸“ç”¨é…ç½®**
```python
# config/travel_mcp.json - æ—…æ¸¸ä¸“ç”¨MCPå·¥å…·é…ç½®
{
  "mcpServers": {
    "maps-service": {
      "command": "python",
      "args": ["src/tools/travel/maps_server.py"],
      "env": {
        "GOOGLE_MAPS_API_KEY": "${GOOGLE_MAPS_API_KEY}",
        "BAIDU_MAPS_API_KEY": "${BAIDU_MAPS_API_KEY}"
      },
      "transport": "stdio"
    },
    "booking-service": {
      "command": "node", 
      "args": ["src/tools/travel/booking_server.js"],
      "env": {
        "BOOKING_API_KEY": "${BOOKING_API_KEY}",
        "AIRBNB_API_KEY": "${AIRBNB_API_KEY}"
      },
      "transport": "stdio"
    },
    "weather-service": {
      "url": "http://localhost:8081/sse",
      "transport": "sse"
    },
    "cultural-guide": {
      "command": "python",
      "args": ["src/tools/travel/cultural_server.py"],
      "env": {
        "WIKI_API_KEY": "${WIKI_API_KEY}"
      },
      "transport": "stdio"
    }
  }
}
```

#### **ç¬¬äºŒæ­¥ï¼šåˆ›å»ºæ—…æ¸¸å·¥å…·ç®¡ç†å™¨**
```python
# src/tools/travel/travel_tool_manager.py

class TravelToolManager:
    """æ—…æ¸¸ä¸“ç”¨å·¥å…·ç®¡ç†å™¨"""
    
    def __init__(self):
        self.travel_tools = {}
        self.tool_categories = TRAVEL_TOOL_CATEGORIES
        
    async def load_travel_tools(self):
        """åŠ è½½æ—…æ¸¸ä¸“ç”¨å·¥å…·"""
        
        # åŠ è½½MCPæ—…æ¸¸å·¥å…·
        travel_mcp_config = self._load_travel_mcp_config()
        travel_mcp_client = MultiServerMCPClient(travel_mcp_config)
        travel_mcp_tools = await travel_mcp_client.get_tools()
        
        for tool in travel_mcp_tools:
            self.travel_tools[tool.name] = tool
        
        # é›†æˆåˆ°ä¸»å·¥å…·ç®¡ç†å™¨
        agent_manager.available_tools.update(self.travel_tools)
        
        logger.info(f"Loaded {len(travel_mcp_tools)} travel-specific tools")
    
    def get_tools_for_travel_type(self, travel_type: str) -> list[str]:
        """æ ¹æ®æ—…æ¸¸ç±»å‹è·å–æ¨èå·¥å…·"""
        
        tool_recommendations = {
            "cultural_tourism": [
                "cultural_guide_generator",
                "historical_site_info", 
                "local_customs_guide"
            ],
            "adventure_tourism": [
                "weather_forecast_travel",
                "terrain_analyzer",
                "emergency_contact_service"
            ],
            "business_tourism": [
                "hotel_search_and_booking",
                "flight_search_comparison", 
                "conference_venue_finder"
            ],
            "family_tourism": [
                "family_friendly_activities",
                "restaurant_recommendations",
                "safety_zone_identifier"
            ]
        }
        
        return tool_recommendations.get(travel_type, [])
```

#### **ç¬¬ä¸‰æ­¥ï¼šåˆ›å»ºæ—…æ¸¸Agent Factoryå·¥ä½œæµ**
```python
# src/workflow/travel_factory_workflow.py

def create_travel_agent_factory_graph():
    """åˆ›å»ºæ—…æ¸¸æ™ºèƒ½ä½“å·¥å‚ä¸“ç”¨å·¥ä½œæµ"""
    
    workflow = AgentWorkflow()
    
    # ä½¿ç”¨æ—…æ¸¸ä¸“ç”¨èŠ‚ç‚¹
    workflow.add_node("travel_coordinator", travel_coordinator_node)
    workflow.add_node("travel_planner", travel_planner_node)  
    workflow.add_node("travel_publisher", travel_publisher_node)
    workflow.add_node("travel_agent_factory", travel_agent_factory_node)
    
    # å·¥ä½œæµè¿æ¥
    workflow.add_edge("travel_coordinator", "travel_planner")
    workflow.add_edge("travel_planner", "travel_publisher") 
    workflow.add_edge("travel_publisher", "travel_agent_factory")
    workflow.add_edge("travel_agent_factory", "__end__")
    
    workflow.set_start("travel_coordinator")
    
    return workflow.compile()

async def travel_agent_factory_node(state: State):
    """æ—…æ¸¸æ™ºèƒ½ä½“å·¥å‚èŠ‚ç‚¹"""
    
    # 1. åº”ç”¨æ—…æ¸¸ä¸“ç”¨æç¤ºè¯
    messages = apply_prompt_template("travel_agent_factory", state)
    
    # 2. ä½¿ç”¨æ¨ç†å‹LLMï¼ˆæ—…æ¸¸è§„åˆ’éœ€è¦å¤æ‚æ¨ç†ï¼‰
    agent_spec = await (
        get_llm_by_type("reasoning")
        .with_structured_output(TravelAgentBuilder)
        .ainvoke(messages)
    )
    
    # 3. éªŒè¯æ—…æ¸¸å·¥å…·å¯ç”¨æ€§
    travel_tool_manager = TravelToolManager()
    verified_tools = await travel_tool_manager.verify_travel_tools(
        agent_spec["selected_tools"]
    )
    
    # 4. åˆ›å»ºæ—…æ¸¸æ™ºèƒ½ä½“
    await agent_manager._create_agent_by_prebuilt(
        user_id=state["user_id"],
        name=agent_spec["agent_name"],
        nick_name=agent_spec["agent_name"],
        llm_type=agent_spec["llm_type"],
        tools=verified_tools,
        prompt=agent_spec["prompt"],
        description=agent_spec["agent_description"],
    )
    
    # 5. è®°å½•æ—…æ¸¸æ™ºèƒ½ä½“åˆ›å»ºæ—¥å¿—
    travel_agent_log = {
        "agent_name": agent_spec["agent_name"],
        "travel_domain": agent_spec.get("travel_domain", "general"),
        "geographic_scope": agent_spec.get("geographic_scope", "unknown"),
        "tools_count": len(verified_tools),
        "creation_time": datetime.now().isoformat()
    }
    
    logger.info(f"Travel agent created: {travel_agent_log}")
    
    return Command(
        update={
            "messages": [{
                "content": f"ğŸŒ æ—…æ¸¸æ™ºèƒ½ä½“ {agent_spec['agent_name']} åˆ›å»ºæˆåŠŸï¼\n"
                          f"ä¸“ä¸šé¢†åŸŸ: {agent_spec.get('travel_domain', 'é€šç”¨æ—…æ¸¸')}\n"
                          f"åœ°ç†èŒƒå›´: {agent_spec.get('geographic_scope', 'å…¨çƒ')}\n"
                          f"é›†æˆå·¥å…·: {len(verified_tools)}ä¸ªä¸“ä¸šæ—…æ¸¸å·¥å…·",
                "tool": "travel_agent_factory",
                "role": "assistant",
            }],
            "new_agent_name": agent_spec["agent_name"],
            "agent_name": "travel_agent_factory",
            "travel_agent_info": travel_agent_log,
        },
        goto="__end__",
    )
```

#### **ç¬¬å››æ­¥ï¼šé›†æˆåˆ°ä¸»ç³»ç»Ÿ**
```python
# src/workflow/process.py - ä¿®æ”¹ä¸»å·¥ä½œæµé€‰æ‹©é€»è¾‘

async def run_agent_workflow(
    user_id: str,
    task_type: str,
    user_input_messages: list,
    ...
):
    """æ‰©å±•çš„å·¥ä½œæµå¯åŠ¨é€»è¾‘"""
    
    # ç°æœ‰é€»è¾‘
    if task_type == TaskType.AGENT_FACTORY:
        graph = agent_factory_graph()
    elif task_type == TaskType.TRAVEL_AGENT_FACTORY:  # æ–°å¢
        graph = create_travel_agent_factory_graph()
    else:
        graph = build_graph()
    
    # å¦‚æœæ˜¯æ—…æ¸¸ç›¸å…³ä»»åŠ¡ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°æ—…æ¸¸å·¥å‚
    if is_travel_related_task(user_input_messages):
        logger.info("Detected travel-related task, switching to travel agent factory")
        graph = create_travel_agent_factory_graph()
    
    # å…¶ä½™é€»è¾‘ä¿æŒä¸å˜...

def is_travel_related_task(messages: list) -> bool:
    """æ£€æµ‹æ˜¯å¦ä¸ºæ—…æ¸¸ç›¸å…³ä»»åŠ¡"""
    
    travel_keywords = [
        "æ—…æ¸¸", "æ—…è¡Œ", "è¡Œç¨‹", "æ™¯ç‚¹", "é…’åº—", "æœºç¥¨", 
        "tourism", "travel", "itinerary", "hotel", "flight",
        "å¯¼æ¸¸", "æ”»ç•¥", "è·¯çº¿", "é¢„è®¢"
    ]
    
    user_input = " ".join([msg.get("content", "") for msg in messages])
    
    return any(keyword in user_input.lower() for keyword in travel_keywords)
```

---

## ğŸ“Š æ€»ç»“ä¸æœ€ä½³å®è·µ

### æ ¸å¿ƒä»·å€¼
1. **åŠ¨æ€æ‰©å±•**: è¿è¡Œæ—¶åˆ›å»ºä¸“ä¸šåŒ–æ™ºèƒ½ä½“ï¼Œæ— éœ€é‡å¯ç³»ç»Ÿ
2. **éœ€æ±‚é€‚é…**: æ ¹æ®å…·ä½“éœ€æ±‚ç²¾ç¡®è®¾è®¡æ™ºèƒ½ä½“é…ç½®
3. **å·¥å…·æ•´åˆ**: æ™ºèƒ½é€‰æ‹©å’Œé›†æˆæœ€ä¼˜çš„å·¥å…·ç»„åˆ
4. **è´¨é‡ä¿è¯**: é€šè¿‡ç»“æ„åŒ–è¾“å‡ºç¡®ä¿é…ç½®çš„å®Œæ•´æ€§å’Œä¸€è‡´æ€§

### Agent Factoryè®¾è®¡è¦ç‚¹
1. **é€šç”¨æ€§ä¼˜å…ˆ**: è®¾è®¡å¯é‡ç”¨çš„é€šç”¨æ™ºèƒ½ä½“ï¼Œé¿å…ä¸€æ¬¡æ€§è§£å†³æ–¹æ¡ˆ
2. **å·¥å…·ç²¾é€‰**: ä¸¥æ ¼é€‰æ‹©å¿…è¦å·¥å…·ï¼Œé¿å…å·¥å…·å†—ä½™å’Œå¤æ‚æ€§
3. **æç¤ºè¯ä¸“ä¸šåŒ–**: ä¸ºæ¯ä¸ªæ™ºèƒ½ä½“åˆ›å»ºä¸“ä¸šåŒ–çš„è¡Œä¸ºæŒ‡å—
4. **é”™è¯¯å®¹é”™**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œå®¹é”™æœºåˆ¶

### æ—…æ¸¸æ™ºèƒ½ä½“å®šåˆ¶è¦ç‚¹
1. **é¢†åŸŸæ·±åº¦**: æ·±å…¥ç†è§£æ—…æ¸¸è¡Œä¸šçš„ä¸“ä¸šéœ€æ±‚å’Œç—›ç‚¹
2. **åœ°ç†æ„ŸçŸ¥**: å¼ºåŒ–åœ°ç†ç©ºé—´æ¨ç†å’Œæ–‡åŒ–æ•æ„Ÿæ€§
3. **å·¥å…·ç”Ÿæ€**: æ„å»ºå®Œæ•´çš„æ—…æ¸¸ä¸“ç”¨å·¥å…·ç”Ÿæ€ç³»ç»Ÿ
4. **ä¸ªæ€§åŒ–**: æ”¯æŒä¸åŒç±»å‹æ—…è¡Œè€…çš„ä¸ªæ€§åŒ–éœ€æ±‚

### æŠ€æœ¯ç‰¹æ€§
- **ç»“æ„åŒ–è¾“å‡º**: é€šè¿‡TypedDictç¡®ä¿é…ç½®çš„ç±»å‹å®‰å…¨
- **æ¨¡å—åŒ–è®¾è®¡**: æ”¯æŒä¸åŒé¢†åŸŸçš„ä¸“ä¸šåŒ–æ‰©å±•
- **å¼‚æ­¥å¤„ç†**: é«˜æ•ˆçš„å¼‚æ­¥æ™ºèƒ½ä½“åˆ›å»ºæµç¨‹
- **å¯è§‚æµ‹æ€§**: å®Œæ•´çš„æ—¥å¿—è®°å½•å’Œç›‘æ§æœºåˆ¶

### æ‰©å±•èƒ½åŠ›
- **å¤šé¢†åŸŸæ”¯æŒ**: æ”¯æŒåŒ»ç–—ã€æ•™è‚²ã€é‡‘èç­‰å„ä¸ªä¸“ä¸šé¢†åŸŸ
- **å¤šè¯­è¨€é€‚é…**: æ”¯æŒä¸åŒè¯­è¨€ç¯å¢ƒçš„æ™ºèƒ½ä½“åˆ›å»º
- **æ’ä»¶æ¶æ„**: æ”¯æŒç¬¬ä¸‰æ–¹å·¥å…·å’Œèƒ½åŠ›çš„æ’ä»¶åŒ–é›†æˆ
- **ç‰ˆæœ¬ç®¡ç†**: æ”¯æŒæ™ºèƒ½ä½“çš„ç‰ˆæœ¬æ§åˆ¶å’Œå‡çº§

Agent Factoryä½œä¸ºCooragentç³»ç»Ÿçš„"æ™ºèƒ½ä½“å­µåŒ–å™¨"ï¼Œå…¶è®¾è®¡è´¨é‡ç›´æ¥å†³å®šäº†ç³»ç»Ÿçš„æ‰©å±•èƒ½åŠ›å’Œé€‚åº”æ€§ã€‚é€šè¿‡ä¸“ä¸šåŒ–çš„éœ€æ±‚åˆ†æã€å·¥å…·é€‰æ‹©å’Œæç¤ºè¯å·¥ç¨‹ï¼Œèƒ½å¤Ÿåˆ›å»ºå‡ºé«˜è´¨é‡çš„ä¸“ä¸šæ™ºèƒ½ä½“ï¼Œä¸ºç”¨æˆ·æä¾›ç²¾å‡†çš„é¢†åŸŸæœåŠ¡ã€‚ 