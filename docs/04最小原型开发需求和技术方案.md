# 最小原型开发需求和技术方案

## 项目概述

实现一个最小可行的Web原型，用户通过"一句话输入需求"，系统后台基于Cooragent核心架构自动生成精简版多智能体应用源代码，打包压缩后提供下载。生成的项目是Cooragent的定制化版本，保留核心功能并针对用户需求进行优化配置。

## 一、功能需求分析

### 1.1 核心功能流程

```
用户输入一句话需求 → 后台智能体协作生成方案 → 自动生成完整项目代码 → 压缩打包 → 提供下载
```

### 1.2 详细功能说明

#### 用户交互界面
- **简洁输入框**: 用户输入自然语言描述的需求
- **生成按钮**: 触发代码生成流程
- **下载按钮**: 生成完成后提供压缩包下载
- **状态提示**: 显示"正在生成..."、"生成完成"等状态

#### 后台处理逻辑
- **需求分析**: 调用现有的coordinator→planner→publisher→agent_proxy工作流
- **智能体配置**: 自动生成或选择合适的智能体配置
- **代码生成**: 根据智能体配置生成完整的可部署项目
- **项目打包**: 自动压缩生成的项目文件
- **文件清理**: 定期清理临时生成的文件

#### 生成的项目结构 (基于Cooragent架构)
```
generated_project/
├── src/                     # 核心源码目录 (基于Cooragent架构)
│   ├── interface/           # 接口定义 (复用Cooragent)
│   │   ├── __init__.py
│   │   ├── agent.py        # 智能体接口定义
│   │   ├── workflow.py     # 工作流接口
│   │   └── serializer.py   # 序列化工具
│   ├── workflow/            # 工作流引擎 (简化版Cooragent)
│   │   ├── __init__.py
│   │   ├── graph.py        # 工作流图定义
│   │   ├── process.py      # 工作流执行器
│   │   └── cache.py        # 状态缓存
│   ├── manager/             # 智能体管理 (精简版)
│   │   ├── __init__.py
│   │   └── agents.py       # 智能体管理器
│   ├── llm/                 # LLM集成 (复用Cooragent)
│   │   ├── __init__.py
│   │   ├── llm.py          # LLM统一接口
│   │   └── agents.py       # 智能体-LLM映射
│   ├── tools/               # 工具集合 (根据需求定制)
│   │   ├── __init__.py
│   │   ├── search.py       # 搜索工具
│   │   ├── python_repl.py  # Python执行器
│   │   └── crawl.py        # 网页爬取工具
│   ├── prompts/             # 提示词模板 (定制化)
│   │   ├── __init__.py
│   │   ├── template.py     # 模板引擎
│   │   ├── coordinator.md  # 协调器提示词
│   │   ├── researcher.md   # 研究员提示词
│   │   └── reporter.md     # 报告员提示词
│   ├── service/             # 服务层 (简化版)
│   │   ├── __init__.py
│   │   ├── server.py       # Web服务器
│   │   └── session.py      # 会话管理
│   └── utils/               # 工具函数
│       ├── __init__.py
│       ├── path_utils.py   # 路径工具
│       └── content_process.py # 内容处理
├── config/                  # 配置目录
│   ├── __init__.py
│   ├── global_variables.py # 全局变量
│   └── workflow.json       # 工作流配置
├── store/                   # 数据存储
│   ├── agents/             # 智能体定义存储
│   ├── prompts/            # 提示词存储
│   └── workflows/          # 工作流缓存
├── cli.py                  # 命令行工具 (简化版)
├── main.py                 # Web应用入口
├── requirements.txt        # 依赖清单
├── .env.example           # 环境变量模板
├── Dockerfile             # Docker部署文件
├── docker-compose.yml     # Docker Compose配置
├── README.md              # 使用说明
└── pyproject.toml         # 项目配置
```

### 1.3 非功能需求

- **响应时间**: 代码生成时间控制在30-60秒内
- **文件大小**: 生成的压缩包不超过10MB
- **并发支持**: 支持多用户同时生成，避免资源冲突
- **错误处理**: 完善的错误提示和异常处理
- **文件清理**: 自动清理超过24小时的临时文件

## 二、技术方案设计

### 2.1 系统架构

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Web 前端      │───→│   FastAPI 后端   │───→│  代码生成器     │
│ (简洁界面)      │    │ (API + 静态文件) │    │ (核心逻辑)      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │                         │
                              ↓                         ↓
                       ┌──────────────┐         ┌─────────────────┐
                       │ 现有工作流   │         │  项目模板库     │
                       │ 系统调用     │         │ (代码模板)      │
                       └──────────────┘         └─────────────────┘
                              │                         │
                              ↓                         ↓
                       ┌──────────────┐         ┌─────────────────┐
                       │ 智能体配置   │         │  文件压缩       │
                       │ 生成结果     │         │  下载服务       │
                       └──────────────┘         └─────────────────┘
```

### 2.2 核心模块设计

#### 2.2.1 项目代码生成器 (基于Cooragent架构)

```python
# src/generator/cooragent_generator.py
class CooragentProjectGenerator:
    """基于Cooragent架构的项目代码生成器"""
    
    def __init__(self):
        self.cooragent_root = Path(__file__).parent.parent.parent  # Cooragent根目录
        self.output_dir = Path("generated_projects")
        
    async def generate_project(self, user_input: str, user_id: str) -> str:
        """生成基于Cooragent的精简项目"""
        # 1. 调用现有工作流系统获取智能体配置
        workflow_result = await self._run_workflow(user_input, user_id)
        
        # 2. 分析生成的智能体和工具需求
        project_config = await self._analyze_project_requirements(workflow_result, user_id)
        
        # 3. 复制Cooragent核心代码并定制化
        project_path = await self._generate_customized_project(project_config, user_id)
        
        # 4. 压缩项目
        zip_path = await self._compress_project(project_path)
        
        return zip_path
    
    async def _run_workflow(self, user_input: str, user_id: str):
        """调用现有工作流系统分析需求"""
        from src.workflow.process import run_agent_workflow
        
        messages = [{"role": "user", "content": user_input}]
        
        # 使用Launch模式分析用户需求并生成智能体配置
        result = await run_agent_workflow(
            user_id=user_id,
            task_type="agent_workflow",
            user_input_messages=messages,
            debug=False,
            deep_thinking_mode=True,
            search_before_planning=True,
            workmode="launch"
        )
                
        return result
    
    async def _analyze_project_requirements(self, workflow_result, user_id: str) -> dict:
        """分析项目需求并确定需要的组件"""
        from src.manager import agent_manager
        
        # 获取本次工作流创建的智能体
        created_agents = []
        used_tools = set()
        
        for agent_name, agent in agent_manager.available_agents.items():
            if agent.user_id == user_id:  # 只获取用户特定的智能体
                created_agents.append(agent)
                # 收集使用的工具
                for tool in agent.selected_tools:
                    used_tools.add(tool.name)
        
        # 分析需要的Cooragent组件
        required_components = self._determine_required_components(created_agents, used_tools)
        
        return {
            "agents": created_agents,
            "tools": list(used_tools),
            "components": required_components,
            "workflow_config": self._generate_workflow_config(created_agents)
        }
    
    def _determine_required_components(self, agents: list, tools: set) -> dict:
        """确定需要复制的Cooragent组件"""
        components = {
            # 核心组件 (总是需要)
            "interface": ["agent.py", "workflow.py", "serializer.py"],
            "workflow": ["graph.py", "process.py", "cache.py"],
            "manager": ["agents.py"],
            "llm": ["llm.py", "agents.py"],
            "prompts": ["template.py"],
            "utils": ["path_utils.py", "content_process.py"],
            "service": ["server.py", "session.py"],
            
            # 根据工具需求选择
            "tools": [],
            "prompts_md": ["coordinator.md"]  # 系统提示词
        }
        
        # 根据使用的工具确定需要复制的工具文件
        tool_mapping = {
            "tavily_tool": "search.py",
            "python_repl_tool": "python_repl.py", 
            "bash_tool": "bash_tool.py",
            "crawl_tool": "crawl.py",
            "browser_tool": "browser.py"
        }
        
        for tool in tools:
            if tool in tool_mapping:
                components["tools"].append(tool_mapping[tool])
        
        # 根据智能体确定需要的提示词
        for agent in agents:
            if agent.agent_name in ["researcher", "coder", "reporter", "browser"]:
                components["prompts_md"].append(f"{agent.agent_name}.md")
        
        return components
    
    async def _generate_customized_project(self, config: dict, user_id: str) -> Path:
        """生成定制化的Cooragent项目"""
        project_name = f"cooragent_app_{user_id}_{int(time.time())}"
        project_path = self.output_dir / project_name
        
        # 创建项目目录结构
        await self._create_project_structure(project_path)
        
        # 复制并定制化Cooragent核心代码
        await self._copy_cooragent_components(project_path, config["components"])
        
        # 生成定制化配置文件
        await self._generate_custom_configs(project_path, config)
        
        # 生成主应用入口
        await self._generate_main_application(project_path, config)
        
        # 生成部署文件
        await self._generate_deployment_files(project_path, config)
        
        # 生成文档
        await self._generate_project_documentation(project_path, config)
        
        return project_path
    
    async def _copy_cooragent_components(self, project_path: Path, components: dict):
        """复制Cooragent核心组件到项目中"""
        import shutil
        
        src_path = project_path / "src"
        
        for component_type, files in components.items():
            if component_type == "prompts_md":
                # 特殊处理提示词文件
                target_dir = src_path / "prompts"
                source_dir = self.cooragent_root / "src" / "prompts"
                
                for file in files:
                    if (source_dir / file).exists():
                        shutil.copy2(source_dir / file, target_dir / file)
            else:
                # 复制其他组件
                target_dir = src_path / component_type
                source_dir = self.cooragent_root / "src" / component_type
                
                target_dir.mkdir(parents=True, exist_ok=True)
                
                for file in files:
                    source_file = source_dir / file
                    if source_file.exists():
                        if source_file.is_file():
                            shutil.copy2(source_file, target_dir / file)
                        else:
                            shutil.copytree(source_file, target_dir / file, dirs_exist_ok=True)
                
                # 确保有__init__.py文件
                init_file = target_dir / "__init__.py"
                if not init_file.exists():
                    init_file.touch()
```

#### 2.2.2 配置和入口文件生成器

```python
# src/generator/config_generator.py
class ConfigGenerator:
    """配置和入口文件生成器"""
    
    async def generate_main_app(self, project_path: Path, config: dict):
        """生成主应用入口文件"""
        main_content = self._render_main_app_template(config)
        
        async with aiofiles.open(project_path / "main.py", "w", encoding="utf-8") as f:
            await f.write(main_content)
    
    def _render_main_app_template(self, config: dict) -> str:
        """渲染主应用模板"""
        agents = config["agents"]
        agent_names = [agent.agent_name for agent in agents]
        
        return f'''"""
基于Cooragent的多智能体应用
自动生成于: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

用户需求生成的智能体: {", ".join(agent_names)}
"""
import asyncio
import logging
from pathlib import Path
from typing import Dict, Any

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

# 导入Cooragent核心组件
from src.workflow.process import run_agent_workflow
from src.manager import agent_manager
from src.service.server import Server
from src.utils.path_utils import get_project_root

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TaskRequest(BaseModel):
    content: str
    user_id: str = "app_user"

class TaskResponse(BaseModel):
    status: str
    result: Dict[str, Any]
    agents_used: list[str]

# 创建FastAPI应用
app = FastAPI(
    title="定制化多智能体应用",
    description="基于Cooragent生成的专业多智能体协作应用",
    version="1.0.0"
)

# 添加CORS中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def startup_event():
    """应用启动时初始化"""
    logger.info("初始化智能体管理器...")
    await agent_manager.initialize()
    logger.info(f"应用启动完成，可用智能体: {{list(agent_manager.available_agents.keys())}}")

@app.get("/")
async def root():
    """健康检查和应用信息"""
    return {{
        "message": "多智能体应用运行正常",
        "available_agents": list(agent_manager.available_agents.keys()),
        "custom_agents": {agent_names},
        "version": "1.0.0",
        "based_on": "Cooragent"
    }}

@app.post("/api/task", response_model=TaskResponse)
async def execute_task(request: TaskRequest):
    """执行智能体任务"""
    try:
        logger.info(f"接收到任务: {{request.content[:100]}}...")
        
        # 使用Cooragent工作流执行任务
        final_state = await run_agent_workflow(
            user_id=request.user_id,
            task_type="agent_workflow",
            user_input_messages=[{{"role": "user", "content": request.content}}],
            debug=False,
            deep_thinking_mode=True,
            search_before_planning=True,
            workmode="production"  # 使用Production模式获得稳定性能
        )
        
        # 提取执行结果
        result = {{
            "task": request.content,
            "final_state": final_state,
            "execution_summary": final_state.get("messages", [])[-1] if final_state.get("messages") else "任务执行完成"
        }}
        
        # 获取使用的智能体列表
        agents_used = []
        for message in final_state.get("messages", []):
            if isinstance(message, dict) and message.get("tool"):
                agents_used.append(message["tool"])
        
        return TaskResponse(
            status="success",
            result=result,
            agents_used=list(set(agents_used))
        )
        
    except Exception as e:
        logger.error(f"任务执行失败: {{str(e)}}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/agents")
async def list_agents():
    """列出所有可用智能体"""
    agents_info = []
    for name, agent in agent_manager.available_agents.items():
        agents_info.append({{
            "name": agent.agent_name,
            "description": agent.description,
            "llm_type": agent.llm_type,
            "tools": [tool.name for tool in agent.selected_tools],
            "user_id": agent.user_id,
            "is_custom": agent.user_id != "share"
        }})
    
    return {{"agents": agents_info}}

@app.get("/api/workflow/{{workflow_id}}")
async def get_workflow_info(workflow_id: str):
    """获取工作流信息"""
    # 这里可以添加工作流状态查询逻辑
    return {{"workflow_id": workflow_id, "status": "completed"}}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
'''
    
    async def generate_custom_workflow_config(self, project_path: Path, config: dict):
        """生成定制化工作流配置"""
        workflow_config = {{
            "workflow_id": "custom_app_workflow",
            "mode": "agent_workflow", 
            "version": 1,
            "user_input_messages": [],
            "agents": []
        }}
        
        # 添加定制智能体配置
        for agent in config["agents"]:
            agent_config = {{
                "agent_name": agent.agent_name,
                "description": agent.description,
                "llm_type": agent.llm_type,
                "selected_tools": [tool.name for tool in agent.selected_tools],
                "prompt": agent.prompt
            }}
            workflow_config["agents"].append(agent_config)
        
        config_dir = project_path / "config"
        config_dir.mkdir(exist_ok=True)
        
        import json
        async with aiofiles.open(config_dir / "workflow.json", "w", encoding="utf-8") as f:
            await f.write(json.dumps(workflow_config, indent=2, ensure_ascii=False))
    
    async def generate_environment_config(self, project_path: Path, config: dict):
        """生成环境配置文件"""
        # 生成.env.example
        env_content = '''# 环境配置文件
# 复制此文件为.env并填入实际值

# LLM配置 (必需)
BASIC_API_KEY=your_openai_api_key_here
BASIC_BASE_URL=https://api.openai.com/v1
BASIC_MODEL=gpt-4

CODE_API_KEY=your_code_llm_api_key_here  
CODE_BASE_URL=https://api.deepseek.com/v1
CODE_MODEL=deepseek-chat

REASONING_API_KEY=your_reasoning_api_key_here
REASONING_BASE_URL=https://api.openai.com/v1
REASONING_MODEL=o1-preview

# 工具API密钥 (根据使用的工具配置)'''

        # 根据使用的工具添加相应的API配置
        if "tavily_tool" in config["tools"]:
            env_content += '''
TAVILY_API_KEY=your_tavily_api_key_here'''
        
        if "browser_tool" in config["tools"]:
            env_content += '''
# 浏览器工具配置
USE_BROWSER=true'''
        
        env_content += '''

# 应用配置
APP_HOST=0.0.0.0
APP_PORT=8000
DEBUG=false
LOG_LEVEL=INFO

# 匿名遥测 (可选)
ANONYMIZED_TELEMETRY=false
'''
        
        async with aiofiles.open(project_path / ".env.example", "w", encoding="utf-8") as f:
            await f.write(env_content)

#### 2.2.3 配置文件生成器

```python
# src/generator/config_generator.py
class ConfigGenerator:
    """配置文件生成器"""
    
    async def generate_requirements(self, project_path: Path, agents: List[Agent]):
        """生成requirements.txt"""
        requirements = self._get_base_requirements()
        
        # 根据智能体使用的工具添加依赖
        for agent in agents:
            for tool in agent.selected_tools:
                tool_deps = self._get_tool_dependencies(tool.name)
                requirements.extend(tool_deps)
        
        # 去重
        requirements = list(set(requirements))
        requirements.sort()
        
        content = "\\n".join(requirements)
        async with aiofiles.open(project_path / "requirements.txt", "w") as f:
            await f.write(content)
    
    def _get_base_requirements(self) -> List[str]:
        """获取基础依赖"""
        return [
            "fastapi>=0.104.0",
            "uvicorn>=0.24.0",
            "pydantic>=2.5.0",
            "python-dotenv>=1.0.0",
            "aiofiles>=23.2.1",
            "httpx>=0.25.0",
            "python-multipart>=0.0.6"
        ]
    
    def _get_tool_dependencies(self, tool_name: str) -> List[str]:
        """根据工具名称获取依赖"""
        tool_deps = {
            "tavily_tool": ["tavily-python>=0.3.0"],
            "python_repl_tool": ["jupyter>=1.0.0"],
            "bash_tool": [],
            "crawl_tool": ["beautifulsoup4>=4.12.0", "requests>=2.31.0"],
            "browser_tool": ["playwright>=1.40.0"]
        }
        return tool_deps.get(tool_name, [])
    
    async def generate_env_example(self, project_path: Path):
        """生成.env.example"""
        content = '''# 环境配置文件示例
# 复制此文件为.env并填入实际值

# LLM配置
OPENAI_API_KEY=your_openai_api_key_here
OPENAI_BASE_URL=https://api.openai.com/v1

# 其他API密钥
TAVILY_API_KEY=your_tavily_api_key_here
SERPER_API_KEY=your_serper_api_key_here

# 应用配置
APP_HOST=0.0.0.0
APP_PORT=8000
DEBUG=false

# 日志配置
LOG_LEVEL=INFO
'''
        async with aiofiles.open(project_path / ".env.example", "w") as f:
            await f.write(content)
    
    async def generate_dockerfile(self, project_path: Path):
        """生成Dockerfile"""
        content = '''FROM python:3.12-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["python", "run.py"]
'''
        async with aiofiles.open(project_path / "Dockerfile", "w") as f:
            await f.write(content)
    
    async def generate_docker_compose(self, project_path: Path):
        """生成docker-compose.yml"""
        content = '''version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    env_file:
      - .env
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  logs:
'''
        async with aiofiles.open(project_path / "docker-compose.yml", "w") as f:
            await f.write(content)
```

### 2.3 Web接口设计 (基于Cooragent Server)

#### 2.3.1 扩展现有API接口

```python
# src/api/generator_api.py  
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends
from fastapi.responses import FileResponse
from pydantic import BaseModel
import asyncio
import uuid
from pathlib import Path
from datetime import datetime

# 导入现有Cooragent组件
from src.service.server import Server
from src.generator.cooragent_generator import CooragentProjectGenerator

class GenerateRequest(BaseModel):
    content: str
    user_id: str = None

class GenerateResponse(BaseModel):
    task_id: str
    status: str
    message: str
    created_at: datetime

class GenerationStatus(BaseModel):
    task_id: str
    status: str  # processing, completed, failed
    message: str
    progress: int = 0
    zip_path: str = None
    created_at: datetime
    completed_at: datetime = None

# 扩展现有Cooragent Server
class GeneratorServer(Server):
    """扩展的代码生成服务器"""
    
    def __init__(self):
        super().__init__()
        self.generator = CooragentProjectGenerator()
        self.generation_tasks = {}
        
        # 添加代码生成路由
        self.add_generation_routes()
    
    def add_generation_routes(self):
        """添加代码生成相关路由"""
        
        @self.app.post("/api/generate", response_model=GenerateResponse)
        async def generate_code(request: GenerateRequest, background_tasks: BackgroundTasks):
            """生成基于Cooragent的项目代码"""
            task_id = str(uuid.uuid4())
            user_id = request.user_id or f"user_{task_id[:8]}"
            
            # 启动后台任务
            background_tasks.add_task(self.run_code_generation, task_id, request.content, user_id)
            
            # 记录任务状态
            self.generation_tasks[task_id] = GenerationStatus(
                task_id=task_id,
                status="processing",
                message="正在分析需求并生成代码...",
                created_at=datetime.now()
            )
            
            return GenerateResponse(
                task_id=task_id,
                status="processing",
                message="代码生成已开始，基于Cooragent架构",
                created_at=datetime.now()
            )
        
        @self.app.get("/api/generate/{task_id}/status", response_model=GenerationStatus)
        async def get_generation_status(task_id: str):
            """获取生成状态"""
            if task_id not in self.generation_tasks:
                raise HTTPException(status_code=404, detail="任务不存在")
            
            return self.generation_tasks[task_id]
        
        @self.app.get("/api/generate/{task_id}/download")
        async def download_code(task_id: str):
            """下载生成的代码"""
            if task_id not in self.generation_tasks:
                raise HTTPException(status_code=404, detail="任务不存在")
            
            task = self.generation_tasks[task_id]
            if task.status != "completed":
                raise HTTPException(status_code=400, detail="代码还未生成完成")
            
            if not task.zip_path or not Path(task.zip_path).exists():
                raise HTTPException(status_code=404, detail="生成的文件不存在")
            
            return FileResponse(
                path=task.zip_path,
                filename=f"cooragent_app_{task_id[:8]}.zip",
                media_type="application/zip"
            )
        
        @self.app.get("/api/generate/examples")
        async def get_examples():
            """获取需求示例"""
            examples = [
                {
                    "title": "股票分析系统",
                    "description": "创建一个股票分析专家agent，查看股票走势，分析热点新闻，预测股价并给出投资建议",
                    "category": "finance"
                },
                {
                    "title": "新闻情感分析",
                    "description": "构建一个新闻分析系统，能够抓取新闻、分析情感并生成摘要报告",
                    "category": "nlp"
                },
                {
                    "title": "数据分析工具",
                    "description": "开发一个数据分析工具，支持CSV文件处理、统计分析和图表生成",
                    "category": "data"
                },
                {
                    "title": "智能客服系统", 
                    "description": "构建一个智能客服系统，能够回答问题、查询信息并记录对话历史",
                    "category": "chatbot"
                },
                {
                    "title": "旅游规划助手",
                    "description": "创建一个旅游规划系统，爬取景点信息，规划行程，生成旅游报告",
                    "category": "travel"
                }
            ]
            return {"examples": examples}
    
    async def run_code_generation(self, task_id: str, content: str, user_id: str):
        """运行代码生成任务"""
        try:
            task = self.generation_tasks[task_id]
            
            # 更新状态：开始分析需求
            task.status = "processing"
            task.message = "正在分析需求并调用Cooragent工作流..."
            task.progress = 10
            
            # 调用Cooragent代码生成器
            zip_path = await self.generator.generate_project(content, user_id)
            
            # 更新状态：生成完成
            task.status = "completed"
            task.message = "基于Cooragent的项目代码生成完成！"
            task.progress = 100
            task.zip_path = str(zip_path)
            task.completed_at = datetime.now()
            
        except Exception as e:
            # 更新状态：生成失败
            task = self.generation_tasks[task_id]
            task.status = "failed"
            task.message = f"生成失败: {str(e)}"
            task.progress = 0
            logger.error(f"代码生成失败 {task_id}: {e}")

# 创建生成器服务实例
generator_server = GeneratorServer()
app = generator_server.app
```

#### 2.3.2 简洁的前端界面

```html
<!-- static/generator.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cooragent 代码生成器</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 700px;
            width: 90%;
            text-align: center;
        }
        
        .header {
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        
        .badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            display: inline-block;
        }
        
        .input-area {
            margin: 30px 0;
        }
        
        .input-box {
            width: 100%;
            min-height: 120px;
            padding: 20px;
            border: 2px solid #e1e5e9;
            border-radius: 15px;
            font-size: 16px;
            resize: vertical;
            transition: border-color 0.3s;
            font-family: inherit;
        }
        
        .input-box:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 600;
            margin: 10px;
        }
        
        .generate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        
        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            margin-top: 30px;
            padding: 20px;
            border-radius: 15px;
            display: none;
        }
        
        .status.processing {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            color: #856404;
        }
        
        .status.completed {
            background: #d4edda;
            border: 2px solid #c3e6cb;
            color: #155724;
        }
        
        .status.failed {
            background: #f8d7da;
            border: 2px solid #f5c6cb;
            color: #721c24;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.3s;
            width: 0%;
        }
        
        .download-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            margin-top: 15px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            font-weight: 600;
        }
        
        .download-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .examples {
            margin-top: 30px;
            text-align: left;
        }
        
        .examples h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .example-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .example-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid #667eea;
        }
        
        .example-item:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }
        
        .example-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .example-desc {
            font-size: 0.9em;
            color: #666;
        }
        
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            color: #999;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">🤖 Cooragent 代码生成器</h1>
            <p class="subtitle">一句话描述需求，自动生成完整的多智能体应用代码</p>
            <span class="badge">基于 Cooragent 架构</span>
        </div>
        
        <div class="input-area">
            <textarea 
                id="userInput" 
                class="input-box" 
                placeholder="请详细描述您的需求，例如：创建一个股票分析系统，能够获取实时股票数据、分析技术指标、爬取相关新闻并生成投资建议报告..."
            ></textarea>
        </div>
        
        <button id="generateBtn" class="generate-btn" onclick="generateCode()">
            🚀 生成 Cooragent 应用
        </button>
        
        <div id="status" class="status">
            <div id="statusMessage"></div>
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="examples">
            <h3>💡 需求示例:</h3>
            <div class="example-grid" id="exampleGrid">
                <!-- 示例将通过JavaScript动态加载 -->
            </div>
        </div>
        
        <div class="footer">
            <p>✨ 基于 Cooragent 多智能体协作平台构建</p>
            <p>🔧 生成的应用包含完整的部署配置和文档</p>
        </div>
    </div>

    <script>
        let currentTaskId = null;
        let examples = [];
        
        // 页面加载时获取示例
        window.onload = async function() {
            await loadExamples();
        };
        
        async function loadExamples() {
            try {
                const response = await fetch('/api/generate/examples');
                const data = await response.json();
                examples = data.examples;
                renderExamples();
            } catch (error) {
                console.error('加载示例失败:', error);
            }
        }
        
        function renderExamples() {
            const grid = document.getElementById('exampleGrid');
            grid.innerHTML = '';
            
            examples.forEach(example => {
                const item = document.createElement('div');
                item.className = 'example-item';
                item.onclick = () => setExample(example.description);
                item.innerHTML = `
                    <div class="example-title">${example.title}</div>
                    <div class="example-desc">${example.description}</div>
                `;
                grid.appendChild(item);
            });
        }
        
        function setExample(description) {
            document.getElementById('userInput').value = description;
        }
        
        async function generateCode() {
            const input = document.getElementById('userInput').value.trim();
            if (!input) {
                alert('请输入您的需求描述');
                return;
            }
            
            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            
            // 禁用按钮
            btn.disabled = true;
            btn.innerHTML = '<span class="loading"></span>正在启动 Cooragent...';
            
            try {
                // 发起生成请求
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: input })
                });
                
                const result = await response.json();
                currentTaskId = result.task_id;
                
                // 显示状态
                showStatus('processing', '🔄 正在调用 Cooragent 工作流分析需求...');
                
                // 开始轮询状态
                pollStatus();
                
            } catch (error) {
                showStatus('failed', '❌ 生成失败: ' + error.message);
                resetButton();
            }
        }
        
        async function pollStatus() {
            if (!currentTaskId) return;
            
            try {
                const response = await fetch(`/api/generate/${currentTaskId}/status`);
                const status = await response.json();
                
                // 更新进度条
                updateProgress(status.progress);
                
                if (status.status === 'completed') {
                    showStatus('completed', 
                        '✅ 基于 Cooragent 的项目代码生成完成！<br>' +
                        '📦 包含完整的多智能体架构和部署配置<br>' +
                        `<a href="/api/generate/${currentTaskId}/download" class="download-btn">📥 下载完整项目</a>`
                    );
                    resetButton();
                } else if (status.status === 'failed') {
                    showStatus('failed', '❌ 生成失败: ' + status.message);
                    resetButton();
                } else {
                    // 更新消息并继续轮询
                    document.getElementById('statusMessage').innerHTML = status.message;
                    setTimeout(pollStatus, 2000);
                }
                
            } catch (error) {
                showStatus('failed', '❌ 状态查询失败: ' + error.message);
                resetButton();
            }
        }
        
        function showStatus(type, message) {
            const status = document.getElementById('status');
            const messageEl = document.getElementById('statusMessage');
            const progressBar = document.getElementById('progressBar');
            
            status.className = 'status ' + type;
            messageEl.innerHTML = message;
            status.style.display = 'block';
            
            if (type === 'processing') {
                progressBar.style.display = 'block';
            } else {
                progressBar.style.display = 'none';
            }
        }
        
        function updateProgress(progress) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = progress + '%';
        }
        
        function resetButton() {
            const btn = document.getElementById('generateBtn');
            btn.disabled = false;
            btn.innerHTML = '🚀 生成 Cooragent 应用';
        }
    </script>
</body>
</html>
```

### 2.4 部署和文件管理

#### 2.4.1 文件清理机制

```python
# src/utils/file_cleaner.py
class FileCleanupManager:
    """文件清理管理器"""
    
    def __init__(self, output_dir: Path, max_age_hours: int = 24):
        self.output_dir = output_dir
        self.max_age_hours = max_age_hours
    
    async def cleanup_old_files(self):
        """清理过期文件"""
        if not self.output_dir.exists():
            return
        
        cutoff_time = datetime.now() - timedelta(hours=self.max_age_hours)
        cleaned_count = 0
        
        for item in self.output_dir.iterdir():
            try:
                if item.stat().st_mtime < cutoff_time.timestamp():
                    if item.is_file():
                        item.unlink()
                    elif item.is_dir():
                        shutil.rmtree(item)
                    cleaned_count += 1
            except Exception as e:
                logger.warning(f"清理文件失败 {item}: {e}")
        
        logger.info(f"清理了 {cleaned_count} 个过期文件/目录")
    
    async def start_cleanup_scheduler(self):
        """启动定时清理任务"""
        while True:
            await asyncio.sleep(3600)  # 每小时执行一次
            await self.cleanup_old_files()
```

#### 2.4.2 压缩功能实现

```python
# src/utils/compression.py
import zipfile
import os

class ProjectCompressor:
    """项目压缩器"""
    
    @staticmethod
    async def compress_project(project_path: Path) -> Path:
        """压缩项目目录"""
        zip_path = project_path.parent / f"{project_path.name}.zip"
        
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(project_path):
                for file in files:
                    file_path = Path(root) / file
                    arc_path = file_path.relative_to(project_path.parent)
                    zipf.write(file_path, arc_path)
        
        # 删除原目录
        shutil.rmtree(project_path)
        
        return zip_path
```

## 三、实施计划 (基于Cooragent架构)

### 3.1 开发阶段

#### 第一阶段：Cooragent集成与代码生成器开发 (1周)
- [ ] 实现CooragentProjectGenerator核心类
- [ ] 完成Cooragent组件复制和定制化逻辑
- [ ] 集成现有的src/workflow/process.py工作流系统
- [ ] 实现基于智能体配置的项目文件生成
- [ ] 测试与现有agent_manager的集成

#### 第二阶段：Web接口扩展开发 (3-4天)
- [ ] 扩展现有的src/service/server.py Server类
- [ ] 实现GeneratorServer和代码生成API路由
- [ ] 开发基于Cooragent的前端界面
- [ ] 完成文件压缩和下载功能
- [ ] 添加任务状态管理和实时轮询

#### 第三阶段：完善和优化 (2-3天)
- [ ] 实现文件清理机制和磁盘管理
- [ ] 优化Cooragent组件选择逻辑
- [ ] 完善生成项目的配置文件模板
- [ ] 添加错误处理和fallback机制
- [ ] 优化用户界面体验和示例

#### 第四阶段：测试和部署 (1-2天)
- [ ] 端到端功能测试（需求→Cooragent工作流→项目生成→部署）
- [ ] 生成项目的独立运行测试
- [ ] 性能优化和稳定性测试
- [ ] Docker部署配置和使用文档

### 3.2 技术风险和解决方案

#### 风险1：Cooragent工作流集成复杂度
**解决方案**: 
- 直接复用现有的run_agent_workflow函数
- 使用Launch模式进行需求分析和智能体生成
- 基于agent_manager获取已生成的智能体配置
- 添加工作流超时和错误重试机制

#### 风险2：组件复制和依赖管理
**解决方案**:
- 创建组件映射表，精确控制复制的文件
- 自动处理依赖关系和import路径
- 生成requirements.txt时根据实际使用的工具动态添加依赖
- 提供组件完整性验证机制

#### 风险3：生成项目的运行稳定性
**解决方案**:
- 基于已验证的Cooragent核心代码，确保稳定性
- 生成的项目包含完整的错误处理和日志系统
- 提供详细的README和部署说明
- 内置健康检查和监控端点

#### 风险4：文件管理和资源控制
**解决方案**:
- 实现定时清理机制，自动删除过期项目
- 设置单个项目大小限制（如50MB）
- 限制并发生成任务数量
- 添加磁盘空间监控和告警

### 3.3 部署方案

#### 开发环境部署
```bash
# 在现有Cooragent项目中添加生成器功能
cd cooragent

# 安装依赖（如果有新增）
uv sync

# 启动扩展的服务器（包含代码生成功能）
uv run python -m src.api.generator_api --port 8000

# 或者使用现有启动方式
uv run python cli.py
# 然后访问 http://localhost:8000/generator.html
```

#### 生产环境部署
```yaml
# docker-compose.yml (扩展现有配置)
version: '3.8'
services:
  cooragent-generator:
    build: .
    ports:
      - "8000:8000"
    environment:
      # Cooragent基础环境变量
      - BASIC_API_KEY=${BASIC_API_KEY}
      - BASIC_BASE_URL=${BASIC_BASE_URL}
      - BASIC_MODEL=${BASIC_MODEL}
      - CODE_API_KEY=${CODE_API_KEY}
      - REASONING_API_KEY=${REASONING_API_KEY}
      - TAVILY_API_KEY=${TAVILY_API_KEY}
      
      # 代码生成器特定配置
      - OUTPUT_DIR=/app/generated_projects
      - CLEANUP_HOURS=24
      - MAX_CONCURRENT_GENERATIONS=5
      - MAX_PROJECT_SIZE_MB=50
    volumes:
      - ./generated_projects:/app/generated_projects
      - ./store:/app/store  # 复用现有的智能体存储
      - ./.env:/app/.env
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  generated_projects:
```

#### 集成现有系统
```bash
# 将代码生成器作为Cooragent的扩展模块
# 在现有的src/service/server.py中添加生成器路由

# 1. 扩展现有Server类
# 2. 添加静态文件服务支持前端界面
# 3. 保持与现有API的兼容性
```

### 3.4 质量保证

#### 自动化测试
- **单元测试**: 测试CooragentProjectGenerator各个方法
- **集成测试**: 测试完整的生成流程（需求→生成→部署）
- **端到端测试**: 测试生成项目的独立运行能力

#### 生成项目验证
- **代码语法检查**: 确保生成的Python代码语法正确
- **依赖完整性**: 验证requirements.txt包含所有必需依赖
- **Docker构建测试**: 确保生成的项目可以成功构建和运行
- **API响应测试**: 验证生成的应用API功能正常

#### 性能基准
- **生成时间**: 目标30-60秒完成项目生成
- **项目大小**: 压缩包通常在5-15MB范围
- **并发能力**: 支持至少5个用户同时生成
- **资源使用**: 单次生成内存使用不超过500MB

## 四、预期成果 (基于Cooragent)

### 4.1 用户体验
- **零学习成本**: 用户无需了解Cooragent架构细节
- **专业质量**: 生成的项目基于成熟的Cooragent架构
- **即时可用**: 下载后直接可以部署运行
- **完整生态**: 生成的项目继承Cooragent的工具和扩展能力

### 4.2 生成的项目特点
- **架构成熟**: 基于已验证的Cooragent多智能体架构
- **功能完整**: 包含工作流引擎、智能体管理、LLM集成等核心功能
- **易于扩展**: 保持与Cooragent生态的兼容性，支持后续扩展
- **部署就绪**: 包含Docker配置、环境变量模板、启动脚本等

### 4.3 技术指标
- **代码复用率**: 80%+ 代码来自Cooragent核心组件
- **生成成功率**: 95%+ （基于成熟组件的稳定性）
- **项目可运行率**: 98%+ （完整的依赖和配置管理）
- **用户满意度**: 目标90%+ （基于专业架构的高质量输出）

### 4.4 商业价值
- **降低门槛**: 将Cooragent从开发框架升级为应用生成器
- **扩大用户群**: 吸引不熟悉多智能体开发的用户
- **生态建设**: 生成的项目天然集成Cooragent生态系统
- **产品差异化**: 提供"一句话生成专业多智能体应用"的独特价值

这个基于Cooragent架构的最小原型将大大降低多智能体应用开发的门槛，同时保持专业水准和技术先进性！ 