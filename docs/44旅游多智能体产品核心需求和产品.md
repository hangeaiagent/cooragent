# æ—…æ¸¸å¤šæ™ºèƒ½ä½“äº§å“æ ¸å¿ƒéœ€æ±‚å’ŒæŠ€æœ¯æ–¹æ¡ˆ

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥åˆ†ææ—…æ¸¸å¤šæ™ºèƒ½ä½“äº§å“çš„3ä¸ªæ ¸å¿ƒåŠŸèƒ½æŠ€æœ¯å®ç°æ–¹æ¡ˆï¼Œé‡ç‚¹é˜è¿°å¦‚ä½•æœ€å¤§åŒ–åˆ©ç”¨ç°æœ‰Cooragentäº§å“ä»£ç å’ŒæŠ€æœ¯æ¶æ„ï¼Œå®ç°é«˜æ•ˆçš„åŠŸèƒ½æ‰©å±•å’Œäº§å“è¿­ä»£ã€‚

---

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½åˆ†æ

### åŠŸèƒ½1ï¼šCç«¯é¡¾å®¢æ—…æ¸¸ç±»å‹æ„å›¾è¯†åˆ«
### åŠŸèƒ½2ï¼šç”¨æˆ·ä¸“å±è¡Œä¸šæ—…æ¸¸çŸ¥è¯†åº“å’Œå•†å“åº“
### åŠŸèƒ½3ï¼šå¤šæ™ºèƒ½ä½“æ–°åˆ›å»ºå’Œè¿­ä»£ä¼˜åŒ–èƒ½åŠ›

---

## ğŸ” ç°æœ‰ä»£ç èµ„äº§åˆ†æ

### 1. **æ—…æ¸¸æ„å›¾è¯†åˆ«ç›¸å…³èµ„äº§**

#### **ç°æœ‰æ ¸å¿ƒç»„ä»¶**
```python
# src/workflow/travel_coordinator.py - ç°æœ‰å®ç°åˆ†æ
class GeographyDetector:           # âœ… å·²æœ‰åœ°ç†ä½ç½®è¯†åˆ«
class TravelTaskClassifier:       # âœ… å·²æœ‰ä»»åŠ¡å¤æ‚åº¦åˆ†æ  
class TravelCoordinator:           # âœ… å·²æœ‰æ—…æ¸¸åè°ƒå™¨æ¡†æ¶
```

#### **ç°æœ‰èƒ½åŠ›è¯„ä¼°**
- **âœ… ä¼˜åŠ¿**ï¼šåŸºç¡€çš„åœ°ç†è¯†åˆ«å’Œä»»åŠ¡åˆ†ç±»æ¡†æ¶å®Œæ•´
- **âš ï¸ ä¸è¶³**ï¼šæ„å›¾åˆ†ç±»ç»´åº¦è¾ƒå°‘ï¼Œç¼ºä¹Cç«¯ä¸“ä¸šåŒ–åˆ†ç±»
- **ğŸš€ æ‰©å±•æ–¹å‘**ï¼šå¢å¼ºæ„å›¾è¯†åˆ«ç²¾åº¦ï¼Œå¢åŠ æ—…æ¸¸ç±»å‹ç»†åˆ†

### 2. **çŸ¥è¯†åº“å’ŒMCPæœåŠ¡ç›¸å…³èµ„äº§**

#### **ç°æœ‰æ ¸å¿ƒç»„ä»¶**
```python
# src/manager/mcp.py - MCPå®¢æˆ·ç«¯é…ç½®ç®¡ç†
def mcp_client_config():           # âœ… å·²æœ‰MCPé…ç½®ç®¡ç†
class AgentManager.load_mcp_tools(): # âœ… å·²æœ‰MCPå·¥å…·é›†æˆ

# src/tools/ - ç°æœ‰MCPæœåŠ¡ç¤ºä¾‹
MCP-Doc/server.py                  # âœ… æ–‡æ¡£å¤„ç†MCPæœåŠ¡å™¨
mcp-image-downloader/              # âœ… å›¾ç‰‡ä¸‹è½½MCPæœåŠ¡å™¨
```

#### **ç°æœ‰èƒ½åŠ›è¯„ä¼°**
- **âœ… ä¼˜åŠ¿**ï¼šå®Œæ•´çš„MCPåè®®é›†æˆæœºåˆ¶
- **âœ… ä¼˜åŠ¿**ï¼šæ ‡å‡†åŒ–çš„æœåŠ¡å™¨é…ç½®å’Œå·¥å…·åŠ è½½æµç¨‹
- **âš ï¸ ä¸è¶³**ï¼šç¼ºä¹æ—…æ¸¸ä¸“ä¸šåŒ–çš„çŸ¥è¯†åº“æœåŠ¡
- **ğŸš€ æ‰©å±•æ–¹å‘**ï¼šåˆ›å»ºæ—…æ¸¸çŸ¥è¯†åº“å’Œå•†å“åº“MCPæœåŠ¡å™¨

### 3. **æ™ºèƒ½ä½“ç®¡ç†ç›¸å…³èµ„äº§**

#### **ç°æœ‰æ ¸å¿ƒç»„ä»¶**
```python
# src/manager/agents.py - æ™ºèƒ½ä½“ç®¡ç†å™¨
class AgentManager:
    async def _create_agent_by_prebuilt()  # âœ… æ™ºèƒ½ä½“åˆ›å»º
    async def _save_agent()                # âœ… æ™ºèƒ½ä½“æŒä¹…åŒ–
    async def _load_agents()               # âœ… æ™ºèƒ½ä½“åŠ è½½

# src/workflow/agent_factory.py - æ™ºèƒ½ä½“å·¥å‚
async def agent_factory_node():           # âœ… è‡ªåŠ¨åŒ–æ™ºèƒ½ä½“åˆ›å»º
```

#### **ç°æœ‰èƒ½åŠ›è¯„ä¼°**
- **âœ… ä¼˜åŠ¿**ï¼šå®Œæ•´çš„æ™ºèƒ½ä½“ç”Ÿå‘½å‘¨æœŸç®¡ç†
- **âœ… ä¼˜åŠ¿**ï¼šè‡ªåŠ¨åŒ–åˆ›å»ºå’Œç»“æ„åŒ–è¾“å‡º
- **âš ï¸ ä¸è¶³**ï¼šç¼ºä¹æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–æœºåˆ¶
- **ğŸš€ æ‰©å±•æ–¹å‘**ï¼šå¢åŠ æ—…æ¸¸ä¸“ä¸šåŒ–å’Œæ€§èƒ½ä¼˜åŒ–

---

## ğŸ› ï¸ æ ¸å¿ƒåŠŸèƒ½æŠ€æœ¯å®ç°æ–¹æ¡ˆ

## åŠŸèƒ½1ï¼šæ—…æ¸¸æ„å›¾è¯†åˆ«å¢å¼ºæ–¹æ¡ˆ

### **1.1 åŸºäºç°æœ‰TravelCoordinatorçš„å¢å¼ºç­–ç•¥**

#### **ç°æœ‰ä»£ç å¤ç”¨åˆ†æ**
```python
# ç°æœ‰ src/workflow/travel_coordinator.py å¤ç”¨ç‚¹ï¼š

# âœ… ç›´æ¥å¤ç”¨ - åœ°ç†æ£€æµ‹å™¨
class GeographyDetector:
    def extract_locations()     # åœ°ç†ä½ç½®æå–
    def classify_region()       # åŒºåŸŸåˆ†ç±» 
    def _is_valid_city_name()   # åŸå¸‚åéªŒè¯

# ğŸ”„ å¢å¼ºå¤ç”¨ - ä»»åŠ¡åˆ†ç±»å™¨  
class TravelTaskClassifier:
    def analyze_complexity()    # éœ€è¦å¢å¼ºä¸ºå¤šç»´åº¦æ„å›¾åˆ†æ
```

#### **æŠ€æœ¯å®ç°æ–¹æ¡ˆ**
```python
# å¢å¼ºæ–¹æ¡ˆï¼šæ‰©å±•ç°æœ‰TravelTaskClassifier
class EnhancedTravelIntentClassifier(TravelTaskClassifier):
    """åŸºäºç°æœ‰åˆ†ç±»å™¨çš„å¢å¼ºç‰ˆæ—…æ¸¸æ„å›¾è¯†åˆ«å™¨"""
    
    def __init__(self):
        super().__init__()
        # å¤ç”¨ç°æœ‰çš„å¤æ‚åº¦å…³é”®è¯
        self.complexity_keywords = self.complexity_keywords
        
        # æ–°å¢ï¼šæ—…æ¸¸ç±»å‹åˆ†ç±»
        self.travel_type_keywords = {
            'leisure_tourism': ['ä¼‘é—²', 'åº¦å‡', 'æ”¾æ¾', 'æµ·æ»©', 'é˜³å…‰'],
            'cultural_tourism': ['æ–‡åŒ–', 'å†å²', 'å¤è¿¹', 'åšç‰©é¦†', 'å¯ºåº™', 'ä¼ ç»Ÿ'],
            'adventure_tourism': ['æ¢é™©', 'æˆ·å¤–', 'ç™»å±±', 'å¾’æ­¥', 'æ½œæ°´', 'æ»‘é›ª'],
            'business_tourism': ['å•†åŠ¡', 'ä¼šè®®', 'å‡ºå·®', 'å·¥ä½œ', 'å•†ä¸š'],
            'family_tourism': ['äº²å­', 'å®¶åº­', 'å„¿ç«¥', 'è€äºº', 'å…¨å®¶'],
            'food_tourism': ['ç¾é£Ÿ', 'å°åƒ', 'ç‰¹äº§', 'é¤å…', 'å½“åœ°èœ'],
            'photography_tourism': ['æ‘„å½±', 'æ‹ç…§', 'é£æ™¯', 'æ‰“å¡', 'ç½‘çº¢'],
            'shopping_tourism': ['è´­ç‰©', 'å•†åœº', 'å…ç¨', 'ç‰¹äº§', 'çºªå¿µå“']
        }
        
        # æ–°å¢ï¼šç´§æ€¥ç¨‹åº¦åˆ†ç±»
        self.urgency_keywords = {
            'urgent': ['æ˜å¤©', 'ä»Šå¤©', 'ç«‹å³', 'é©¬ä¸Š', 'ç´§æ€¥'],
            'soon': ['è¿™å‘¨', 'ä¸‹å‘¨', 'å°½å¿«', 'è¿‘æœŸ'],
            'flexible': ['æœ‰æ—¶é—´', 'ä¸æ€¥', 'ä»€ä¹ˆæ—¶å€™éƒ½è¡Œ', 'è®¡åˆ’ä¸­']
        }
        
        # æ–°å¢ï¼šé¢„ç®—ç­‰çº§å…³é”®è¯
        self.budget_keywords = {
            'luxury': ['è±ªå', 'é«˜ç«¯', 'äº”æ˜Ÿ', 'å¥¢å', 'ä¸å·®é’±'],
            'mid_range': ['ä¸­ç­‰', 'é€‚ä¸­', 'åˆç†', 'æ€§ä»·æ¯”'],
            'budget': ['ä¾¿å®œ', 'ç»æµ', 'çœé’±', 'ç©·æ¸¸', 'å­¦ç”Ÿ']
        }
    
    def analyze_travel_intent(self, messages: List[Dict[str, Any]]) -> Dict[str, str]:
        """å¢å¼ºçš„æ—…æ¸¸æ„å›¾åˆ†æ"""
        content = " ".join([msg.get("content", "") for msg in messages])
        
        result = {
            'is_travel_request': self._is_travel_request(content),
            'travel_type': self._classify_travel_type(content),
            'urgency_level': self._classify_urgency(content),
            'budget_level': self._classify_budget(content),
            'complexity': self.analyze_complexity(messages)  # å¤ç”¨ç°æœ‰æ–¹æ³•
        }
        
        return result
    
    def _is_travel_request(self, content: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæ—…æ¸¸è¯·æ±‚ - æ–°å¢åŠŸèƒ½"""
        travel_indicators = [
            'æ—…æ¸¸', 'æ—…è¡Œ', 'å‡ºæ¸¸', 'åº¦å‡', 'æ¸¸ç©', 'è‡ªç”±è¡Œ', 'è·Ÿå›¢',
            'æœºç¥¨', 'é…’åº—', 'æ™¯ç‚¹', 'æ”»ç•¥', 'è·¯çº¿', 'è¡Œç¨‹',
            'å»', 'åˆ°', 'ç©', 'æ¸¸', 'é€›', 'çœ‹', 'å‚è§‚'
        ]
        
        # éæ—…æ¸¸å…³é”®è¯
        non_travel_indicators = [
            'å·¥ä½œ', 'å­¦ä¹ ', 'ç¼–ç¨‹', 'ä»£ç ', 'å¼€å‘', 'æŠ€æœ¯',
            'å¥åº·', 'åŒ»ç–—', 'æ³•å¾‹', 'é‡‘è', 'è‚¡ç¥¨'
        ]
        
        travel_score = sum(1 for word in travel_indicators if word in content)
        non_travel_score = sum(1 for word in non_travel_indicators if word in content)
        
        return travel_score > non_travel_score and travel_score > 0
    
    def _classify_travel_type(self, content: str) -> str:
        """æ—…æ¸¸ç±»å‹åˆ†ç±» - æ–°å¢åŠŸèƒ½"""
        scores = {}
        for travel_type, keywords in self.travel_type_keywords.items():
            scores[travel_type] = sum(1 for keyword in keywords if keyword in content)
        
        if max(scores.values()) == 0:
            return 'general'
        
        return max(scores, key=scores.get)
    
    def _classify_urgency(self, content: str) -> str:
        """ç´§æ€¥ç¨‹åº¦åˆ†ç±» - æ–°å¢åŠŸèƒ½"""
        for urgency, keywords in self.urgency_keywords.items():
            if any(keyword in content for keyword in keywords):
                return urgency
        return 'flexible'
    
    def _classify_budget(self, content: str) -> str:
        """é¢„ç®—ç­‰çº§åˆ†ç±» - æ–°å¢åŠŸèƒ½"""
        for budget, keywords in self.budget_keywords.items():
            if any(keyword in content for keyword in keywords):
                return budget
        return 'mid_range'
```

#### **é›†æˆåˆ°ç°æœ‰TravelCoordinator**
```python
# ä¿®æ”¹ src/workflow/travel_coordinator.py
class TravelCoordinator:
    def __init__(self):
        self.geo_detector = GeographyDetector()        # âœ… å¤ç”¨ç°æœ‰
        # ğŸ”„ æ›¿æ¢ï¼šä½¿ç”¨å¢å¼ºç‰ˆåˆ†ç±»å™¨
        self.travel_classifier = EnhancedTravelIntentClassifier()
        logger.info("TravelCoordinator ä½¿ç”¨å¢å¼ºæ„å›¾è¯†åˆ«å™¨åˆå§‹åŒ–å®Œæˆ")
    
    async def coordinate_travel_request(self, state: State) -> Command:
        """å¢å¼ºçš„æ—…æ¸¸è¯·æ±‚åè°ƒé€»è¾‘"""
        
        messages = state.get("messages", [])
        if not messages:
            return Command(goto="__end__")
        
        # 1. æ—…æ¸¸æ„å›¾åˆ†æ - æ–°å¢
        intent_analysis = self.travel_classifier.analyze_travel_intent(messages)
        
        # æ—©æœŸè¿‡æ»¤ï¼šéæ—…æ¸¸è¯·æ±‚
        if not intent_analysis['is_travel_request']:
            return Command(
                update={
                    "messages": [{
                        "content": "æŠ±æ­‰ï¼Œæˆ‘æ˜¯ä¸“ä¸šçš„æ—…æ¸¸è§„åˆ’åŠ©æ‰‹ï¼Œä¸»è¦ååŠ©æ‚¨åˆ¶å®šæ—…æ¸¸è®¡åˆ’ã€‚å¦‚æœ‰å…¶ä»–é—®é¢˜ï¼Œå»ºè®®å’¨è¯¢ç›¸å…³ä¸“ä¸šæœåŠ¡ã€‚",
                        "role": "assistant"
                    }]
                },
                goto="__end__"
            )
        
        # 2. åœ°ç†ä½ç½®è¯†åˆ« - âœ… å¤ç”¨ç°æœ‰
        departure, destination = self.geo_detector.extract_locations(messages)
        travel_region = self.geo_detector.classify_region(destination) if destination else "unknown"
        
        # 3. æ™ºèƒ½è·¯ç”±å†³ç­– - å¢å¼º
        routing_decision = self._enhanced_routing_decision(intent_analysis, departure, destination)
        
        # æ›´æ–°çŠ¶æ€
        state.update({
            "travel_intent": intent_analysis,
            "departure": departure,
            "destination": destination,
            "travel_region": travel_region,
            "routing_decision": routing_decision
        })
        
        return Command(
            update=state,
            goto=routing_decision["next_node"]
        )
```

### **1.2 å®æ–½æ­¥éª¤**

#### **é˜¶æ®µ1ï¼šå¿«é€Ÿå¢å¼ºï¼ˆ1å‘¨ï¼‰**
1. **æ‰©å±•TravelTaskClassifier**
   - åœ¨ç°æœ‰ç±»åŸºç¡€ä¸Šå¢åŠ æ–°çš„åˆ†ç±»ç»´åº¦
   - ä¿æŒå‘åå…¼å®¹æ€§
   
2. **é›†æˆåˆ°TravelCoordinator**
   - æœ€å°åŒ–ä»£ç ä¿®æ”¹
   - å¤ç”¨ç°æœ‰çš„çŠ¶æ€ç®¡ç†å’Œè·¯ç”±é€»è¾‘

#### **é˜¶æ®µ2ï¼šæ·±åº¦ä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰**
1. **è®­ç»ƒä¸“ä¸šåŒ–æ¨¡å‹**
   - åŸºäºCç«¯æ•°æ®è®­ç»ƒæ„å›¾è¯†åˆ«æ¨¡å‹
   - é›†æˆåˆ°ç°æœ‰åˆ†ç±»å™¨ä¸­
   
2. **A/Bæµ‹è¯•æ¡†æ¶**
   - å¯¹æ¯”æ–°æ—§åˆ†ç±»å™¨æ•ˆæœ
   - åŠ¨æ€è°ƒæ•´åˆ†ç±»ç­–ç•¥

---

## åŠŸèƒ½2ï¼šæ—…æ¸¸çŸ¥è¯†åº“å’Œå•†å“åº“æ–¹æ¡ˆ

### **2.1 åŸºäºç°æœ‰MCPæœºåˆ¶çš„æ‰©å±•ç­–ç•¥**

#### **ç°æœ‰ä»£ç å¤ç”¨åˆ†æ**
```python
# âœ… å®Œå…¨å¤ç”¨ - MCPé…ç½®ç®¡ç†
# src/manager/mcp.py
def mcp_client_config():           # MCPæœåŠ¡å™¨é…ç½®è¯»å–
class AgentManager.load_mcp_tools() # MCPå·¥å…·è‡ªåŠ¨åŠ è½½

# âœ… å‚è€ƒå¤ç”¨ - MCPæœåŠ¡å™¨å®ç°æ¨¡å¼
# src/tools/MCP-Doc/server.py      # æ–‡æ¡£å¤„ç†æœåŠ¡å™¨æ¨¡å¼
# src/tools/mcp-image-downloader/  # å›¾ç‰‡å¤„ç†æœåŠ¡å™¨æ¨¡å¼
```

#### **æŠ€æœ¯å®ç°æ–¹æ¡ˆ**
```python
# æ–°å»ºï¼šsrc/tools/travel-knowledge-mcp/server.py
from fastmcp import FastMCP
from typing import Dict, List, Any, Optional
import json
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

class TravelKnowledgeProcessor:
    """æ—…æ¸¸çŸ¥è¯†åº“å¤„ç†å™¨ - åŸºäºç°æœ‰MCPæ¨¡å¼"""
    
    def __init__(self):
        # çŸ¥è¯†åº“å­˜å‚¨è·¯å¾„
        self.knowledge_base_dir = Path("data/travel_knowledge")
        self.product_catalog_dir = Path("data/product_catalog")
        
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        self.knowledge_base_dir.mkdir(parents=True, exist_ok=True)
        self.product_catalog_dir.mkdir(parents=True, exist_ok=True)
        
        # ç”¨æˆ·ä¸“å±çŸ¥è¯†åº“ç´¢å¼•
        self.user_knowledge_index = {}
        self.product_index = {}
        
    def load_user_knowledge(self, user_id: str) -> Dict[str, Any]:
        """åŠ è½½ç”¨æˆ·ä¸“å±çŸ¥è¯†åº“"""
        knowledge_file = self.knowledge_base_dir / f"{user_id}_knowledge.json"
        
        if knowledge_file.exists():
            with open(knowledge_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            # è¿”å›é»˜è®¤ç»“æ„
            return {
                "destinations": [],
                "accommodations": [],
                "activities": [],
                "restaurants": [],
                "transportation": [],
                "preferences": {}
            }
    
    def save_user_knowledge(self, user_id: str, knowledge_data: Dict[str, Any]) -> bool:
        """ä¿å­˜ç”¨æˆ·ä¸“å±çŸ¥è¯†åº“"""
        try:
            knowledge_file = self.knowledge_base_dir / f"{user_id}_knowledge.json"
            with open(knowledge_file, 'w', encoding='utf-8') as f:
                json.dump(knowledge_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception as e:
            logger.error(f"ä¿å­˜ç”¨æˆ·çŸ¥è¯†åº“å¤±è´¥: {e}")
            return False

# âœ… å¤ç”¨ç°æœ‰MCPæœåŠ¡å™¨æ¨¡å¼
processor = TravelKnowledgeProcessor()

# åˆ›å»ºMCPæœåŠ¡å™¨ - å®Œå…¨å¤ç”¨ç°æœ‰æ¨¡å¼
mcp = FastMCP(
    name="TravelKnowledgeBase",
    instructions="æ—…æ¸¸çŸ¥è¯†åº“å’Œå•†å“åº“æœåŠ¡ï¼Œæä¾›ä¸ªæ€§åŒ–æ—…æ¸¸ä¿¡æ¯æŸ¥è¯¢å’Œå•†å“æ¨èåŠŸèƒ½"
)

@mcp.tool()
def search_destinations(user_id: str, query: str, region: str = "all") -> str:
    """
    æœç´¢æ—…æ¸¸ç›®çš„åœ°ä¿¡æ¯
    
    Parameters:
    - user_id: ç”¨æˆ·ID
    - query: æœç´¢å…³é”®è¯
    - region: åŒºåŸŸé™åˆ¶ (china/international/all)
    """
    try:
        user_knowledge = processor.load_user_knowledge(user_id)
        destinations = user_knowledge.get("destinations", [])
        
        # åŸºäºå…³é”®è¯å’ŒåŒºåŸŸè¿‡æ»¤
        filtered_destinations = []
        for dest in destinations:
            if region != "all" and dest.get("region") != region:
                continue
            if query.lower() in dest.get("name", "").lower() or \
               query.lower() in dest.get("description", "").lower():
                filtered_destinations.append(dest)
        
        return json.dumps({
            "status": "success",
            "results": filtered_destinations,
            "count": len(filtered_destinations)
        }, ensure_ascii=False)
        
    except Exception as e:
        logger.error(f"æœç´¢ç›®çš„åœ°ä¿¡æ¯å¤±è´¥: {e}")
        return json.dumps({"status": "error", "message": str(e)})

@mcp.tool()
def search_products(user_id: str, product_type: str, criteria: str) -> str:
    """
    æœç´¢æ—…æ¸¸å•†å“
    
    Parameters:
    - user_id: ç”¨æˆ·ID  
    - product_type: å•†å“ç±»å‹ (packages/hotels/flights/activities/services)
    - criteria: æœç´¢æ¡ä»¶JSONå­—ç¬¦ä¸²
    """
    try:
        # è§£ææœç´¢æ¡ä»¶
        search_criteria = json.loads(criteria) if criteria else {}
        
        # åŠ è½½å•†å“åº“
        product_file = processor.product_catalog_dir / f"{product_type}.json"
        if not product_file.exists():
            return json.dumps({"status": "error", "message": f"å•†å“ç±»å‹ {product_type} ä¸å­˜åœ¨"})
        
        with open(product_file, 'r', encoding='utf-8') as f:
            products = json.load(f)
        
        # åº”ç”¨æœç´¢æ¡ä»¶
        filtered_products = processor._filter_products(products, search_criteria)
        
        # åŸºäºç”¨æˆ·åå¥½æ’åº
        user_knowledge = processor.load_user_knowledge(user_id)
        ranked_products = processor._rank_products_by_preference(
            filtered_products, 
            user_knowledge.get("preferences", {})
        )
        
        return json.dumps({
            "status": "success", 
            "products": ranked_products[:10],  # è¿”å›å‰10ä¸ªç»“æœ
            "total_count": len(filtered_products)
        }, ensure_ascii=False)
        
    except Exception as e:
        logger.error(f"æœç´¢å•†å“å¤±è´¥: {e}")
        return json.dumps({"status": "error", "message": str(e)})

@mcp.tool()
def update_user_knowledge(user_id: str, category: str, data: str) -> str:
    """
    æ›´æ–°ç”¨æˆ·ä¸“å±çŸ¥è¯†åº“
    
    Parameters:
    - user_id: ç”¨æˆ·ID
    - category: çŸ¥è¯†ç±»åˆ« (destinations/accommodations/activities/restaurants/transportation/preferences)
    - data: çŸ¥è¯†æ•°æ®JSONå­—ç¬¦ä¸²
    """
    try:
        # åŠ è½½ç°æœ‰çŸ¥è¯†åº“
        user_knowledge = processor.load_user_knowledge(user_id)
        
        # è§£ææ–°æ•°æ®
        new_data = json.loads(data)
        
        # æ›´æ–°å¯¹åº”ç±»åˆ«
        if category in user_knowledge:
            if isinstance(user_knowledge[category], list):
                user_knowledge[category].extend(new_data if isinstance(new_data, list) else [new_data])
            else:
                user_knowledge[category].update(new_data)
        else:
            user_knowledge[category] = new_data
        
        # ä¿å­˜æ›´æ–°åçš„çŸ¥è¯†åº“
        if processor.save_user_knowledge(user_id, user_knowledge):
            return json.dumps({"status": "success", "message": f"æˆåŠŸæ›´æ–° {category} çŸ¥è¯†åº“"})
        else:
            return json.dumps({"status": "error", "message": "ä¿å­˜çŸ¥è¯†åº“å¤±è´¥"})
            
    except Exception as e:
        logger.error(f"æ›´æ–°ç”¨æˆ·çŸ¥è¯†åº“å¤±è´¥: {e}")
        return json.dumps({"status": "error", "message": str(e)})

if __name__ == "__main__":
    mcp.run()
```

#### **MCPé…ç½®é›†æˆ - âœ… å®Œå…¨å¤ç”¨ç°æœ‰æœºåˆ¶**
```json
// config/mcp.json - æ·»åŠ æ–°çš„æ—…æ¸¸çŸ¥è¯†åº“æœåŠ¡
{
  "mcpServers": {
    // âœ… ä¿ç•™ç°æœ‰æœåŠ¡é…ç½®
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/generated_projects"]
    },
    "mcp-doc": {
      "command": "python",
      "args": ["/path/to/src/tools/MCP-Doc/server.py"],
      "env": {}
    },
    
    // ğŸ”„ æ–°å¢ï¼šæ—…æ¸¸çŸ¥è¯†åº“æœåŠ¡
    "travel-knowledge": {
      "command": "python", 
      "args": ["/path/to/src/tools/travel-knowledge-mcp/server.py"],
      "env": {
        "KNOWLEDGE_BASE_PATH": "/path/to/data/travel_knowledge",
        "PRODUCT_CATALOG_PATH": "/path/to/data/product_catalog"
      }
    },
    
    // ğŸ”„ æ–°å¢ï¼šå•†å“æ¨èæœåŠ¡
    "travel-products": {
      "command": "python",
      "args": ["/path/to/src/tools/travel-products-mcp/server.py"], 
      "env": {
        "RECOMMENDATION_MODEL_PATH": "/path/to/models/recommendation"
      }
    }
  }
}
```

#### **é›†æˆåˆ°ç°æœ‰AgentManager - âœ… é›¶ä»£ç ä¿®æ”¹**
```python
# ç°æœ‰çš„ src/manager/agents.py æ— éœ€ä¿®æ”¹
# æ–°çš„MCPæœåŠ¡ä¼šé€šè¿‡ç°æœ‰æœºåˆ¶è‡ªåŠ¨åŠ è½½

class AgentManager:
    async def load_mcp_tools(self):
        # âœ… ç°æœ‰ä»£ç è‡ªåŠ¨åŠ è½½æ–°çš„æ—…æ¸¸çŸ¥è¯†åº“å·¥å…·
        mcp_client = MultiServerMCPClient(mcp_client_config())
        mcp_tools = await mcp_client.get_tools()
        for _tool in mcp_tools:
            # æ–°çš„å·¥å…·ä¼šè‡ªåŠ¨æ·»åŠ åˆ°å¯ç”¨å·¥å…·åˆ—è¡¨
            self.available_tools[_tool.name] = _tool
            
    # æ–°çš„å·¥å…·åç§°å°†åŒ…æ‹¬ï¼š
    # - search_destinations
    # - search_products  
    # - update_user_knowledge
    # - recommend_personalized_products
```

### **2.2 ä¸ªæ€§åŒ–æ¨èå¢å¼º**

#### **æ™ºèƒ½æ¨èæœåŠ¡å™¨å®ç°**
```python
# æ–°å»ºï¼šsrc/tools/travel-products-mcp/server.py
class PersonalizationEngine:
    """ä¸ªæ€§åŒ–æ¨èå¼•æ“ - åŸºäºç”¨æˆ·è¡Œä¸ºå’Œåå¥½"""
    
    def __init__(self):
        self.user_behavior_tracker = {}
        self.product_similarity_matrix = {}
        
    def track_user_interaction(self, user_id: str, interaction_data: Dict[str, Any]):
        """è¿½è¸ªç”¨æˆ·äº¤äº’è¡Œä¸º"""
        if user_id not in self.user_behavior_tracker:
            self.user_behavior_tracker[user_id] = []
        
        self.user_behavior_tracker[user_id].append({
            "timestamp": datetime.now().isoformat(),
            "action": interaction_data.get("action"),
            "product_id": interaction_data.get("product_id"),
            "category": interaction_data.get("category"),
            "rating": interaction_data.get("rating", 0)
        })
    
    def generate_recommendations(self, user_id: str, category: str, count: int = 10) -> List[Dict]:
        """ç”Ÿæˆä¸ªæ€§åŒ–æ¨è"""
        user_profile = self._build_user_profile(user_id)
        candidate_products = self._get_candidate_products(category)
        
        # ååŒè¿‡æ»¤ + å†…å®¹è¿‡æ»¤
        scores = {}
        for product in candidate_products:
            collaborative_score = self._calculate_collaborative_score(user_id, product)
            content_score = self._calculate_content_score(user_profile, product)
            
            # åŠ æƒç»„åˆ
            final_score = 0.6 * collaborative_score + 0.4 * content_score
            scores[product["id"]] = final_score
        
        # æ’åºå¹¶è¿”å›å‰Nä¸ª
        recommended_ids = sorted(scores.keys(), key=lambda x: scores[x], reverse=True)[:count]
        return [self._get_product_by_id(pid) for pid in recommended_ids]

@mcp.tool()
def get_personalized_recommendations(user_id: str, category: str, preferences: str = "{}") -> str:
    """
    è·å–ä¸ªæ€§åŒ–æ¨è
    
    Parameters:
    - user_id: ç”¨æˆ·ID
    - category: æ¨èç±»åˆ«
    - preferences: ç”¨æˆ·åå¥½JSONå­—ç¬¦ä¸²
    """
    try:
        engine = PersonalizationEngine()
        recommendations = engine.generate_recommendations(user_id, category)
        
        return json.dumps({
            "status": "success",
            "recommendations": recommendations,
            "personalization_score": engine.calculate_personalization_score(user_id)
        }, ensure_ascii=False)
        
    except Exception as e:
        return json.dumps({"status": "error", "message": str(e)})
```

### **2.3 å®æ–½æ­¥éª¤**

#### **é˜¶æ®µ1ï¼šåŸºç¡€æœåŠ¡æ­å»ºï¼ˆ1-2å‘¨ï¼‰**
1. **åˆ›å»ºæ—…æ¸¸çŸ¥è¯†åº“MCPæœåŠ¡å™¨**
   - âœ… å¤ç”¨ç°æœ‰MCPæœåŠ¡å™¨æ¨¡å¼
   - âœ… é›¶ä¿®æ”¹é›†æˆåˆ°ç°æœ‰é…ç½®ç³»ç»Ÿ
   
2. **æ•°æ®ç»“æ„è®¾è®¡å’Œåˆå§‹åŒ–**
   - è®¾è®¡ç”¨æˆ·çŸ¥è¯†åº“æ•°æ®ç»“æ„
   - å»ºç«‹å•†å“åº“æ•°æ®æ¨¡å‹

#### **é˜¶æ®µ2ï¼šä¸ªæ€§åŒ–æ¨èï¼ˆ2-3å‘¨ï¼‰**
1. **æ¨èç®—æ³•å®ç°**
   - ååŒè¿‡æ»¤æ¨èå¼•æ“
   - å†…å®¹è¿‡æ»¤æ¨èå¼•æ“
   
2. **ç”¨æˆ·è¡Œä¸ºè¿½è¸ª**
   - é›†æˆåˆ°ç°æœ‰SessionManager
   - å®æ—¶è¡Œä¸ºæ•°æ®æ”¶é›†

---

## åŠŸèƒ½3ï¼šæ™ºèƒ½ä½“åˆ›å»ºå’Œä¼˜åŒ–æ–¹æ¡ˆ

### **3.1 åŸºäºç°æœ‰AgentFactoryçš„å¢å¼ºç­–ç•¥**

#### **ç°æœ‰ä»£ç å¤ç”¨åˆ†æ**
```python
# âœ… å®Œå…¨å¤ç”¨ - æ ¸å¿ƒæ™ºèƒ½ä½“ç®¡ç†
# src/manager/agents.py
class AgentManager:
    async def _create_agent_by_prebuilt()  # æ™ºèƒ½ä½“åˆ›å»ºæœºåˆ¶
    async def _save_agent()                # æ™ºèƒ½ä½“æŒä¹…åŒ–
    async def _load_agents()               # æ™ºèƒ½ä½“åŠ è½½

# âœ… æ‰©å±•å¤ç”¨ - æ™ºèƒ½ä½“å·¥å‚
# src/workflow/agent_factory.py
async def agent_factory_node()             # è‡ªåŠ¨åŒ–åˆ›å»ºæµç¨‹
```

#### **æŠ€æœ¯å®ç°æ–¹æ¡ˆ**
```python
# å¢å¼ºæ–¹æ¡ˆï¼šæ‰©å±•ç°æœ‰AgentManager
class TravelAgentManager(AgentManager):
    """æ—…æ¸¸ä¸“ä¸šåŒ–æ™ºèƒ½ä½“ç®¡ç†å™¨ - åŸºäºç°æœ‰AgentManager"""
    
    def __init__(self, tools_dir, agents_dir, prompt_dir):
        # âœ… å®Œå…¨ç»§æ‰¿ç°æœ‰åˆå§‹åŒ–
        super().__init__(tools_dir, agents_dir, prompt_dir)
        
        # ğŸ”„ æ–°å¢ï¼šæ—…æ¸¸ä¸“ä¸šåŒ–åŠŸèƒ½
        self.performance_tracker = TravelAgentPerformanceTracker()
        self.optimization_engine = AgentOptimizationEngine()
        self.travel_templates = TravelAgentTemplateManager()
        
    async def create_specialized_travel_agent(
        self,
        user_id: str,
        travel_domain: str,         # 'culture_tour', 'adventure', 'family_trip'
        user_preferences: Dict[str, Any],
        performance_requirements: Dict[str, float]
    ) -> Agent:
        """åˆ›å»ºä¸“ä¸šåŒ–æ—…æ¸¸æ™ºèƒ½ä½“ - åŸºäºç°æœ‰åˆ›å»ºæœºåˆ¶"""
        
        # 1. è·å–æ—…æ¸¸é¢†åŸŸä¸“ä¸šæ¨¡æ¿
        agent_template = self.travel_templates.get_template(travel_domain)
        
        # 2. åŸºäºç”¨æˆ·åå¥½å®šåˆ¶
        customized_config = self._customize_agent_config(
            agent_template, 
            user_preferences
        )
        
        # 3. âœ… å¤ç”¨ç°æœ‰åˆ›å»ºæœºåˆ¶
        agent = await self._create_agent_by_prebuilt(
            user_id=user_id,
            name=customized_config["name"],
            nick_name=customized_config["nick_name"], 
            llm_type=customized_config["llm_type"],
            tools=customized_config["tools"],
            prompt=customized_config["prompt"],
            description=customized_config["description"]
        )
        
        # 4. ğŸ”„ æ–°å¢ï¼šæ³¨å†Œæ€§èƒ½è¿½è¸ª
        self.performance_tracker.register_agent(
            agent.agent_name,
            travel_domain,
            performance_requirements
        )
        
        return agent
    
    async def optimize_existing_agent(
        self,
        agent_id: str,
        performance_data: Dict[str, float],
        user_feedback: List[Dict[str, Any]]
    ) -> OptimizationResult:
        """ä¼˜åŒ–ç°æœ‰æ™ºèƒ½ä½“ - æ–°å¢åŠŸèƒ½"""
        
        # 1. åŠ è½½ç°æœ‰æ™ºèƒ½ä½“ - âœ… å¤ç”¨ç°æœ‰æœºåˆ¶
        if agent_id not in self.available_agents:
            await self._load_agent(agent_id, user_agent_flag=True)
        
        current_agent = self.available_agents[agent_id]
        
        # 2. æ€§èƒ½åˆ†æ
        optimization_recommendations = self.optimization_engine.analyze_performance(
            current_agent,
            performance_data,
            user_feedback
        )
        
        # 3. åº”ç”¨ä¼˜åŒ–
        if optimization_recommendations["should_optimize"]:
            optimized_config = self.optimization_engine.generate_optimized_config(
                current_agent,
                optimization_recommendations
            )
            
            # 4. âœ… å¤ç”¨ç°æœ‰ä¿å­˜æœºåˆ¶
            updated_agent = await self._update_agent_config(current_agent, optimized_config)
            await self._save_agent(updated_agent, flush=True)
            
            return OptimizationResult(
                success=True,
                improvements=optimization_recommendations["improvements"],
                new_config=optimized_config
            )
        
        return OptimizationResult(success=False, reason="æ— éœ€ä¼˜åŒ–")

# ğŸ”„ æ–°å¢ï¼šæ™ºèƒ½ä½“æ€§èƒ½è¿½è¸ªå™¨
class TravelAgentPerformanceTracker:
    """æ—…æ¸¸æ™ºèƒ½ä½“æ€§èƒ½è¿½è¸ªå™¨"""
    
    def __init__(self):
        self.performance_data = {}
        self.metrics_definitions = {
            "response_accuracy": "å›ç­”å‡†ç¡®æ€§",
            "user_satisfaction": "ç”¨æˆ·æ»¡æ„åº¦", 
            "task_completion_rate": "ä»»åŠ¡å®Œæˆç‡",
            "response_time": "å¹³å‡å“åº”æ—¶é—´",
            "conversion_rate": "å’¨è¯¢è½¬åŒ–ç‡"
        }
    
    def track_interaction(
        self,
        agent_id: str,
        interaction_data: Dict[str, Any]
    ):
        """è¿½è¸ªæ™ºèƒ½ä½“äº¤äº’æ•°æ®"""
        if agent_id not in self.performance_data:
            self.performance_data[agent_id] = {
                "interactions": [],
                "metrics": {},
                "created_at": datetime.now().isoformat()
            }
        
        self.performance_data[agent_id]["interactions"].append({
            "timestamp": datetime.now().isoformat(),
            "user_id": interaction_data.get("user_id"),
            "query": interaction_data.get("query"),
            "response": interaction_data.get("response"),
            "user_rating": interaction_data.get("rating"),
            "task_completed": interaction_data.get("completed", False),
            "response_time": interaction_data.get("response_time", 0)
        })
        
        # å®æ—¶æ›´æ–°æ€§èƒ½æŒ‡æ ‡
        self._update_metrics(agent_id)
    
    def get_performance_report(self, agent_id: str) -> Dict[str, Any]:
        """è·å–æ™ºèƒ½ä½“æ€§èƒ½æŠ¥å‘Š"""
        if agent_id not in self.performance_data:
            return {"error": "æ™ºèƒ½ä½“æ€§èƒ½æ•°æ®ä¸å­˜åœ¨"}
        
        data = self.performance_data[agent_id]
        metrics = data["metrics"]
        
        return {
            "agent_id": agent_id,
            "total_interactions": len(data["interactions"]),
            "performance_metrics": metrics,
            "trend_analysis": self._analyze_trends(agent_id),
            "optimization_suggestions": self._generate_suggestions(metrics)
        }

# ğŸ”„ æ–°å¢ï¼šæ™ºèƒ½ä½“ä¼˜åŒ–å¼•æ“
class AgentOptimizationEngine:
    """æ™ºèƒ½ä½“è‡ªåŠ¨ä¼˜åŒ–å¼•æ“"""
    
    def __init__(self):
        self.optimization_strategies = {
            "prompt_optimization": PromptOptimizer(),
            "tool_selection": ToolSelectionOptimizer(), 
            "llm_model_selection": LLMModelOptimizer()
        }
    
    def analyze_performance(
        self,
        agent: Agent,
        performance_data: Dict[str, float],
        user_feedback: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """åˆ†ææ™ºèƒ½ä½“æ€§èƒ½å¹¶ç”Ÿæˆä¼˜åŒ–å»ºè®®"""
        
        # æ€§èƒ½é˜ˆå€¼æ£€æŸ¥
        performance_thresholds = {
            "user_satisfaction": 4.0,     # æ»¡æ„åº¦ä½äº4.0éœ€è¦ä¼˜åŒ–
            "task_completion_rate": 0.8,  # å®Œæˆç‡ä½äº80%éœ€è¦ä¼˜åŒ–
            "response_accuracy": 0.85      # å‡†ç¡®ç‡ä½äº85%éœ€è¦ä¼˜åŒ–
        }
        
        optimization_needed = {}
        for metric, threshold in performance_thresholds.items():
            current_value = performance_data.get(metric, 0)
            if current_value < threshold:
                optimization_needed[metric] = {
                    "current": current_value,
                    "target": threshold,
                    "gap": threshold - current_value
                }
        
        # ç”¨æˆ·åé¦ˆåˆ†æ
        feedback_analysis = self._analyze_user_feedback(user_feedback)
        
        # ç”Ÿæˆä¼˜åŒ–ç­–ç•¥
        strategies = []
        if optimization_needed:
            if "user_satisfaction" in optimization_needed:
                strategies.append("prompt_optimization")
            if "task_completion_rate" in optimization_needed:
                strategies.append("tool_selection")
            if "response_accuracy" in optimization_needed:
                strategies.append("llm_model_selection")
        
        return {
            "should_optimize": len(optimization_needed) > 0,
            "performance_gaps": optimization_needed,
            "feedback_insights": feedback_analysis,
            "recommended_strategies": strategies,
            "improvements": self._estimate_improvements(optimization_needed, strategies)
        }
    
    def generate_optimized_config(
        self,
        current_agent: Agent,
        optimization_recommendations: Dict[str, Any]
    ) -> Dict[str, Any]:
        """ç”Ÿæˆä¼˜åŒ–åçš„æ™ºèƒ½ä½“é…ç½®"""
        
        optimized_config = {
            "name": current_agent.agent_name,
            "nick_name": current_agent.nick_name,
            "description": current_agent.description,
            "llm_type": current_agent.llm_type,
            "tools": current_agent.selected_tools,
            "prompt": current_agent.prompt
        }
        
        # åº”ç”¨ä¼˜åŒ–ç­–ç•¥
        for strategy in optimization_recommendations["recommended_strategies"]:
            optimizer = self.optimization_strategies[strategy]
            optimized_config = optimizer.optimize(optimized_config, optimization_recommendations)
        
        return optimized_config
```

#### **é›†æˆåˆ°ç°æœ‰workflow - âœ… æœ€å°åŒ–ä¿®æ”¹**
```python
# ä¿®æ”¹ src/workflow/agent_factory.py - å¢å¼ºç°æœ‰factory_node
async def enhanced_travel_agent_factory_node(state: State) -> Command[Literal["publisher", "__end__"]]:
    """å¢å¼ºçš„æ—…æ¸¸æ™ºèƒ½ä½“å·¥å‚èŠ‚ç‚¹"""
    
    logger.info("Enhanced Travel Agent Factory å¼€å§‹å·¥ä½œ")
    
    # âœ… ä¿ç•™ç°æœ‰çš„æ¨¡æ¿åº”ç”¨æœºåˆ¶
    messages = apply_prompt_template("agent_factory", state)
    
    # ğŸ”„ å¢å¼ºï¼šä½¿ç”¨æ—…æ¸¸ä¸“ä¸šåŒ–çš„ç»“æ„åŒ–è¾“å‡º
    agent_spec = await (
        get_llm_by_type(AGENT_LLM_MAP["agent_factory"])
        .with_structured_output(TravelAgentBuilder)  # æ‰©å±•çš„ç»“æ„åŒ–è¾“å‡º
        .ainvoke(messages)
    )
    
    # ğŸ”„ å¢å¼ºï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºä¸“ä¸šåŒ–æ—…æ¸¸æ™ºèƒ½ä½“
    travel_intent = state.get("travel_intent", {})
    travel_type = travel_intent.get("travel_type", "general")
    
    if travel_type != "general":
        # åˆ›å»ºä¸“ä¸šåŒ–æ—…æ¸¸æ™ºèƒ½ä½“
        travel_agent_manager = TravelAgentManager(
            tools_dir=agent_manager.tools_dir,
            agents_dir=agent_manager.agents_dir, 
            prompt_dir=agent_manager.prompt_dir
        )
        
        agent = await travel_agent_manager.create_specialized_travel_agent(
            user_id=state["user_id"],
            travel_domain=travel_type,
            user_preferences=state.get("user_preferences", {}),
            performance_requirements={"user_satisfaction": 4.5, "conversion_rate": 0.3}
        )
    else:
        # âœ… å›é€€åˆ°ç°æœ‰åˆ›å»ºæœºåˆ¶
        tools = []
        for tool in agent_spec["selected_tools"]:
            if agent_manager.available_tools.get(tool["name"]):
                tools.append(agent_manager.available_tools[tool["name"]])
        
        agent = await agent_manager._create_agent_by_prebuilt(
            user_id=state["user_id"],
            name=agent_spec["agent_name"],
            nick_name=agent_spec["agent_name"],
            llm_type=agent_spec["llm_type"],
            tools=tools,
            prompt=agent_spec["prompt"],
            description=agent_spec["agent_description"],
        )
    
    # âœ… ä¿ç•™ç°æœ‰çš„çŠ¶æ€æ›´æ–°é€»è¾‘
    state["TEAM_MEMBERS"].append(agent.agent_name)
    
    return Command(
        update={
            "messages": [{
                "content": f"ä¸“ä¸šæ—…æ¸¸æ™ºèƒ½ä½“ {agent.agent_name} åˆ›å»ºæˆåŠŸï¼Œä¸“é•¿é¢†åŸŸï¼š{travel_type}",
                "tool": "travel_agent_factory",
                "role": "assistant",
            }],
            "new_agent_name": agent.agent_name,
            "agent_name": "travel_agent_factory",
        },
        goto="publisher",
    )
```

### **3.2 æ™ºèƒ½ä½“ç®¡ç†åå°é›†æˆ**

#### **åå°ç®¡ç†API - åŸºäºç°æœ‰FastAPIæœåŠ¡å™¨**
```python
# æ‰©å±• src/service/server.py - æ·»åŠ æ™ºèƒ½ä½“ç®¡ç†æ¥å£
from src.manager.agents import TravelAgentManager, TravelAgentPerformanceTracker

class Server:
    def __init__(self, host="0.0.0.0", port=8001) -> None:
        # âœ… ä¿ç•™ç°æœ‰åˆå§‹åŒ–
        self.host = host
        self.port = port
        
        # ğŸ”„ æ–°å¢ï¼šæ—…æ¸¸æ™ºèƒ½ä½“ç®¡ç†å™¨
        self.travel_agent_manager = TravelAgentManager(
            tools_dir=Path("store/tools"),
            agents_dir=Path("store/agents"),
            prompt_dir=Path("store/prompts")
        )
        self.performance_tracker = TravelAgentPerformanceTracker()

# ğŸ”„ æ–°å¢ï¼šæ™ºèƒ½ä½“ç®¡ç†APIæ¥å£
@app.get("/api/agents/list")
async def list_travel_agents(user_id: str = None):
    """è·å–æ—…æ¸¸æ™ºèƒ½ä½“åˆ—è¡¨"""
    try:
        agents = await server.travel_agent_manager.get_user_agents(user_id)
        return {
            "status": "success",
            "agents": [
                {
                    "id": agent.agent_name,
                    "name": agent.nick_name,
                    "description": agent.description,
                    "domain": agent.metadata.get("travel_domain", "general"),
                    "performance": server.performance_tracker.get_performance_summary(agent.agent_name)
                }
                for agent in agents
            ]
        }
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.get("/api/agents/{agent_id}/performance")
async def get_agent_performance(agent_id: str):
    """è·å–æ™ºèƒ½ä½“æ€§èƒ½æŠ¥å‘Š"""
    try:
        report = server.performance_tracker.get_performance_report(agent_id)
        return {"status": "success", "report": report}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.post("/api/agents/{agent_id}/optimize")
async def optimize_agent(agent_id: str, optimization_request: OptimizationRequest):
    """ä¼˜åŒ–æ™ºèƒ½ä½“"""
    try:
        result = await server.travel_agent_manager.optimize_existing_agent(
            agent_id=agent_id,
            performance_data=optimization_request.performance_data,
            user_feedback=optimization_request.user_feedback
        )
        return {"status": "success", "result": result}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.post("/api/agents/review/duplicates")
async def review_duplicate_agents():
    """è¯†åˆ«é‡å¤æ™ºèƒ½ä½“"""
    try:
        duplicates = await server.travel_agent_manager.identify_duplicate_agents()
        return {"status": "success", "duplicates": duplicates}
    except Exception as e:
        return {"status": "error", "message": str(e)}
```

### **3.3 å®æ–½æ­¥éª¤**

#### **é˜¶æ®µ1ï¼šæ€§èƒ½è¿½è¸ªç³»ç»Ÿï¼ˆ1-2å‘¨ï¼‰**
1. **æ‰©å±•ç°æœ‰AgentManager**
   - âœ… ç»§æ‰¿ç°æœ‰ç±»ï¼Œä¿æŒå…¼å®¹æ€§
   - ğŸ”„ æ·»åŠ æ€§èƒ½è¿½è¸ªåŠŸèƒ½
   
2. **é›†æˆåˆ°ç°æœ‰å·¥ä½œæµ**
   - âœ… æœ€å°åŒ–ä¿®æ”¹ç°æœ‰agent_factory
   - ğŸ”„ å¢å¼ºä¸“ä¸šåŒ–åˆ›å»ºèƒ½åŠ›

#### **é˜¶æ®µ2ï¼šä¼˜åŒ–å¼•æ“ï¼ˆ2-3å‘¨ï¼‰**
1. **æ™ºèƒ½ä½“ä¼˜åŒ–ç®—æ³•**
   - åŸºäºæ€§èƒ½æ•°æ®çš„è‡ªåŠ¨ä¼˜åŒ–
   - A/Bæµ‹è¯•æ¡†æ¶é›†æˆ
   
2. **ç®¡ç†åå°ç•Œé¢**
   - âœ… åŸºäºç°æœ‰FastAPIæœåŠ¡å™¨
   - ğŸ”„ æ·»åŠ ç®¡ç†APIæ¥å£

---

## ğŸ“Š ä»£ç å¤ç”¨ç‡åˆ†æ

### **å¤ç”¨ç‡ç»Ÿè®¡**

| åŠŸèƒ½æ¨¡å— | ç°æœ‰ä»£ç å¤ç”¨ç‡ | æ–°å¢ä»£ç é‡ | ä¿®æ”¹ç°æœ‰ä»£ç é‡ |
|----------|----------------|------------|----------------|
| **æ—…æ¸¸æ„å›¾è¯†åˆ«** | 80% | 20% | 5% |
| **çŸ¥è¯†åº“å’Œå•†å“åº“** | 95% | 5% | 0% |
| **æ™ºèƒ½ä½“ç®¡ç†ä¼˜åŒ–** | 85% | 15% | 3% |

### **å…·ä½“å¤ç”¨ç‚¹**

#### **âœ… å®Œå…¨å¤ç”¨ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰**
- MCPæœåŠ¡å™¨é…ç½®æœºåˆ¶ (`src/manager/mcp.py`)
- MCPå·¥å…·è‡ªåŠ¨åŠ è½½ (`AgentManager.load_mcp_tools()`)
- æ™ºèƒ½ä½“åˆ›å»ºæœºåˆ¶ (`AgentManager._create_agent_by_prebuilt()`)
- æ™ºèƒ½ä½“æŒä¹…åŒ– (`AgentManager._save_agent()`)
- FastAPIæœåŠ¡å™¨æ¡†æ¶ (`src/service/server.py`)

#### **ğŸ”„ æ‰©å±•å¤ç”¨ï¼ˆæœ€å°åŒ–ä¿®æ”¹ï¼‰**
- æ—…æ¸¸åè°ƒå™¨å¢å¼º (åŸºäº`TravelCoordinator`)
- æ™ºèƒ½ä½“å·¥å‚å¢å¼º (åŸºäº`agent_factory_node`)
- æ™ºèƒ½ä½“ç®¡ç†å™¨å¢å¼º (ç»§æ‰¿`AgentManager`)

#### **ğŸ†• æ–°å¢ç»„ä»¶**
- æ—…æ¸¸çŸ¥è¯†åº“MCPæœåŠ¡å™¨
- æ™ºèƒ½ä½“æ€§èƒ½è¿½è¸ªå™¨
- ä¸ªæ€§åŒ–æ¨èå¼•æ“

---

## ğŸš€ å®æ–½ä¼˜åŠ¿åˆ†æ

### **æŠ€æœ¯ä¼˜åŠ¿**
1. **ä½é£é™©å®æ–½**ï¼šåŸºäºæˆç†Ÿä»£ç ï¼Œå‡å°‘å¼€å‘é£é™©
2. **å¿«é€Ÿäº¤ä»˜**ï¼šé«˜å¤ç”¨ç‡ï¼Œç¼©çŸ­å¼€å‘å‘¨æœŸ
3. **å‘åå…¼å®¹**ï¼šä¸ç ´åç°æœ‰åŠŸèƒ½ï¼Œå¹³æ»‘å‡çº§
4. **æ ‡å‡†åŒ–æ‰©å±•**ï¼šåŸºäºMCPåè®®ï¼Œæ˜“äºç»´æŠ¤

### **æˆæœ¬ä¼˜åŠ¿**
1. **å¼€å‘æˆæœ¬é™ä½60%**ï¼šå¤§é‡å¤ç”¨ç°æœ‰ä»£ç 
2. **æµ‹è¯•æˆæœ¬é™ä½50%**ï¼šç°æœ‰æœºåˆ¶å·²éªŒè¯
3. **ç»´æŠ¤æˆæœ¬é™ä½40%**ï¼šç»Ÿä¸€çš„æ¶æ„å’Œæ ‡å‡†

### **æ—¶é—´ä¼˜åŠ¿**
1. **ç¬¬ä¸€é˜¶æ®µ**ï¼š2-3å‘¨å®Œæˆæ ¸å¿ƒåŠŸèƒ½
2. **ç¬¬äºŒé˜¶æ®µ**ï¼š3-4å‘¨å®Œæˆé«˜çº§åŠŸèƒ½
3. **æ€»ä½“æ—¶é—´**ï¼šç›¸æ¯”é‡æ–°å¼€å‘ï¼ŒèŠ‚çœ70%æ—¶é—´

---

## ğŸ“‹ æ€»ç»“

é€šè¿‡æ·±å…¥åˆ†æç°æœ‰Cooragentä»£ç èµ„äº§ï¼Œæˆ‘ä»¬åˆ¶å®šäº†ä¸€ä¸ª**é«˜å¤ç”¨ç‡ã€ä½é£é™©ã€å¿«é€Ÿäº¤ä»˜**çš„æŠ€æœ¯å®æ–½æ–¹æ¡ˆï¼š

### **æ ¸å¿ƒç­–ç•¥**
- **æœ€å¤§åŒ–å¤ç”¨**ï¼šå¹³å‡å¤ç”¨ç‡è¾¾åˆ°85%ä»¥ä¸Š
- **æœ€å°åŒ–ä¿®æ”¹**ï¼šå¯¹ç°æœ‰ä»£ç çš„ä¿®æ”¹ä¸è¶…è¿‡5%
- **æ ‡å‡†åŒ–æ‰©å±•**ï¼šåŸºäºç°æœ‰MCPå’ŒAgentManageræœºåˆ¶

### **å®æ–½è·¯å¾„**
- **ç»§æ‰¿å¼å¢å¼º**ï¼šåŸºäºç°æœ‰ç±»è¿›è¡ŒåŠŸèƒ½æ‰©å±•
- **æ’ä»¶å¼é›†æˆ**ï¼šé€šè¿‡MCPåè®®æ— ç¼é›†æˆæ–°æœåŠ¡
- **æ¸è¿›å¼ä¼˜åŒ–**ï¼šä¿æŒå‘åå…¼å®¹çš„åŒæ—¶å¢å¼ºåŠŸèƒ½

è¿™ä¸ªæ–¹æ¡ˆç¡®ä¿åœ¨å……åˆ†åˆ©ç”¨ç°æœ‰æŠ€æœ¯èµ„äº§çš„åŒæ—¶ï¼Œå®ç°æ—…æ¸¸å¤šæ™ºèƒ½ä½“äº§å“çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä¸ºå¿«é€Ÿè¿›å…¥å¸‚åœºå¥ å®šåšå®çš„æŠ€æœ¯åŸºç¡€ã€‚ 